"use strict";
/*
 * Copyright (C) OmniStation, Inc - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Martin C. Euerle, <meuerle@omnistation.com>,  2019.10.14
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonApiToTypeScript = void 0;
const DataType_1 = require("../../data/entity/DataType");
const ClassFor_1 = require("../../data/ClassFor");
const EntityManager_1 = require("../../data/EntityManager");
const LogManager_1 = require("../../utils/log/LogManager");
const JsonApiDocument_1 = require("../JsonApiDocument");
const JsonApiError_1 = require("../JsonApiError");
const JSONObject_1 = require("../util/JSONObject");
const EntityWebReflectionUtils_1 = require("../util/EntityWebReflectionUtils");
const JsonApiErrorMeta_1 = require("../JsonApiErrorMeta");
const ErrorBase_1 = require("../../lang/ErrorBase");
const JsonApiPersistableBase_1 = require("../JsonApiPersistableBase");
const JsonApiQuery_1 = require("../JsonApiQuery");
const QueryParam_1 = require("../util/QueryParam");
const QueryParamArray_1 = require("../util/QueryParamArray");
const log_1 = require("../../utils/log");
//import { objectFactory as ObjectFactory }   from "../../../../jsonApiUtil/objectFactory";
/*
import { ObjectMap }                        from "../mapping/ObjectMap";
import { ObjectMapElement }                 from "../mapping/ObjectMapElement";
import { ObjectMapper }                     from "../mapping/ObjectMapper";

import { Attribute }                  from "../mapping/Attribute";

import { ReflectionUtils }                  from "./ReflectionUtils";

let LOGGER       : Logger            = LogManager.getInstance().getLogger("com.comnistation.jsonapi.transform.JsonApiToTypeScript");
*/
const NAMESPACE = "com.salesstryke.jsonapi.transform.JsonApiToTypeScript";
const LOGGER = LogManager_1.LogManager.getLogger(NAMESPACE);
LOGGER.setLogLevel(log_1.Level.INFO);
class JsonApiToTypeScript {
    constructor() {
        this.jsonApiDocument_c = new JsonApiDocument_1.JsonApiDocument();
        this.clearAllMutatedFlags_b = false;
        this.isMutatedSuppressedFlag_b = false;
    }
    setClearAllMutatdFlages(clearAllMutatedFlags_b) {
        this.clearAllMutatedFlags_b = clearAllMutatedFlags_b;
        return (this);
    }
    setIsMutatedSuppressed(isMutatedSuppressed_b) {
        this.isMutatedSuppressedFlag_b = isMutatedSuppressed_b;
        return (this);
    }
    /**
     *
     */
    execute(jsonApi_s = null) {
        // Reset internal state before each execution
        this.jsonApiDocument_c = new JsonApiDocument_1.JsonApiDocument();
        const jsonApiDocument_jo = new JSONObject_1.JSONObject(jsonApi_s);
        this.jsonObjectToJsonApiDocument(jsonApiDocument_jo);
        if (LOGGER.isInfoEnabled()) {
            LOGGER.logInfo({ message: `from source string : ${jsonApi_s}`, methodName: this.execute.name, uuid: 'cdeea2a9-b622-429c-98f8-8348afeac309' });
        }
        return (this.jsonApiDocument_c);
    }
    /**
     *
     */
    executeJSONObject(jsonObject_p) {
        this.jsonObjectToJsonApiDocument(jsonObject_p);
        return (this.jsonApiDocument_c);
    }
    // NOTE TODO: rename to jsonStringToEntity
    static jsonToEntity(json_s) {
        let jsonApiBase = null;
        try {
            const temp_any = new JsonApiToTypeScript().jsonToTypeScriptClass(json_s);
            if (temp_any !== null) {
                jsonApiBase = temp_any;
            }
        }
        catch (error_any) {
            const errorBase = new ErrorBase_1.ErrorBase('Failed', NAMESPACE, this.jsonToEntity.name, '0dcf8467-2aad-4681-9769-b8ebf7c98971', error_any);
            if (LOGGER.isErrorEnabled()) {
                LOGGER.logErrorBase(errorBase);
            }
            throw (errorBase);
        }
        return (jsonApiBase);
    }
    jsonToTypeScriptClass(json_s) {
        const jsonObject = new JSONObject_1.JSONObject(json_s);
        const jsonApiBase = this.getAsJsonApiBase(jsonObject);
        return (jsonApiBase);
    }
    /**
     *
     */
    initJsonApiDocumentTopLevel(jsonApiDocument_jo) {
        const rootNames_ary = jsonApiDocument_jo.getNames();
        rootNames_ary.forEach((name_s) => {
            if (name_s === "data") {
                const data_ja = jsonApiDocument_jo.getJSONArray("data");
                if (data_ja !== null) {
                    const size_i = data_ja.size();
                    for (let index_i = 0; index_i < size_i; index_i++) {
                        const dataItem_jo = data_ja.get(index_i);
                        if (dataItem_jo !== null) {
                            const newInstance_any = this.getAsJsonApiBase(dataItem_jo);
                            if (newInstance_any === null || newInstance_any === undefined) {
                                const error = new Error(`JsonApiToTypeScript.getAsJsonApiBase failed to create instance for dataItem: ${JSON.stringify(dataItem_jo, null, 2)}`);
                                const errorBase = new ErrorBase_1.ErrorBase(error.message, NAMESPACE, this.initJsonApiDocumentTopLevel.name, "b0c1f8d2-3a4e-4f5b-9c6d-7e8f9a0b1c2d", error);
                                LOGGER.logErrorBase(errorBase);
                            }
                            this.jsonApiDocument_c.addData(newInstance_any);
                        }
                    }
                }
            }
            else if (name_s === "errors") {
                const errors_ja = jsonApiDocument_jo.getJSONArray("errors");
                let dataItemIndex_i = 0;
                if (errors_ja !== null) {
                    for (dataItemIndex_i = 0; dataItemIndex_i < errors_ja.size(); dataItemIndex_i++) {
                        const errorItem_jo = errors_ja.getJSONObject(dataItemIndex_i);
                        if (errorItem_jo !== null) {
                            const jsonError_m = this.getJsonApiError(errorItem_jo);
                            this.jsonApiDocument_c.addError(jsonError_m);
                        }
                    }
                }
            }
            else if (name_s === JsonApiQuery_1.JsonApiQuery.metadata.jsonName) {
                const jsonApiQuery_jo = jsonApiDocument_jo.getJSONObject(JsonApiQuery_1.JsonApiQuery.metadata.jsonName);
                if (jsonApiQuery_jo !== null) {
                    const pageNumber_i = jsonApiQuery_jo.getNumber(JsonApiQuery_1.JsonApiQuery.metadata.attributes.pageNumber, 0);
                    const pageSize_i = jsonApiQuery_jo.getNumber(JsonApiQuery_1.JsonApiQuery.metadata.attributes.pageSize, 0);
                    const resultCount_i = jsonApiQuery_jo.getNumber(JsonApiQuery_1.JsonApiQuery.metadata.attributes.resultCount, 0);
                    const jsonApiQuery = new JsonApiQuery_1.JsonApiQuery().setPageNumber(pageNumber_i).setPageSize(pageSize_i).setResultCount(resultCount_i);
                    const queryParam_ja = jsonApiQuery_jo.getJSONArray(JsonApiQuery_1.JsonApiQuery.metadata.attributes.queryParams);
                    if (queryParam_ja) {
                        const size_i = queryParam_ja.size();
                        for (let index_i = 0; index_i < size_i; index_i++) {
                            const queryParam_jo = queryParam_ja.get(index_i);
                            const name_s = queryParam_jo.get('name');
                            const dataType_s = queryParam_jo.get('dataType');
                            const entity_s = queryParam_jo.get('entity');
                            const value_any = queryParam_jo.get('value');
                            let values_any = queryParam_jo.get('values');
                            if (name_s === 'createdDate') {
                                let noop = 0;
                            }
                            // In case com.salesstryke.jsonapi.QueryParamArray changes, have an OR clause to check for values_any instead of entity_s
                            if (entity_s === 'com.salesstryke.jsonapi.QueryParamArray' || values_any) {
                                // this is an Array
                                // If values_any is a JSONArray and not a native array, convert it to a native array of dataType_s
                                // in our case it should always be a JSONArray
                                if (values_any && typeof values_any === 'object' && typeof values_any.size === 'function' && !Array.isArray(values_any)) {
                                    // Convert JSONArray to native array
                                    const arr = [];
                                    for (let i = 0; i < values_any.size(); i++) {
                                        let item = values_any.get(i);
                                        // convert item to dataType_s if needed
                                        switch (dataType_s) {
                                            case DataType_1.DataType.FLOAT.getId():
                                            case DataType_1.DataType.NUMBER.getId():
                                                item = Number(item);
                                                break;
                                            case DataType_1.DataType.STRING.getId():
                                                item = String(item);
                                                break;
                                            case DataType_1.DataType.BOOLEAN.getId():
                                                item = Boolean(item);
                                                break;
                                            // Add more cases as needed
                                            case DataType_1.DataType.DATE.getId():
                                                // Assuming item is a date string, you can convert it to a Date object
                                                item = new Date(item);
                                                break;
                                        }
                                        arr.push(item);
                                    }
                                    values_any = arr;
                                }
                                const queryParam = new QueryParamArray_1.QueryParamArray(name_s, dataType_s, values_any);
                                jsonApiQuery.addQueryParam(queryParam);
                            }
                            // not an array
                            else {
                                const queryParam = new QueryParam_1.QueryParam(name_s, dataType_s, value_any);
                                jsonApiQuery.addQueryParam(queryParam);
                            }
                        }
                    }
                    this.jsonApiDocument_c.setQuery(jsonApiQuery);
                }
            }
        });
    }
    /**
     *
     */
    getJsonApiError(jsonApiErrorItem_jo) {
        const jsonError = new JsonApiError_1.JsonApiError();
        const names_ary = jsonApiErrorItem_jo.getNames();
        let index_i = 0;
        for (index_i = 0; index_i < names_ary.length; index_i++) {
            const name_s = names_ary[index_i];
            let value_any = null;
            if (name_s === "meta") {
                value_any = jsonApiErrorItem_jo.getJSONObject(name_s);
            }
            else {
                value_any = jsonApiErrorItem_jo.getString(name_s);
            }
            if (value_any !== undefined && value_any !== null) {
                const value_s = value_any;
                if (name_s === "code") {
                    jsonError.setCode(value_s);
                }
                else if (name_s === "detail") {
                    jsonError.setDetail(value_s);
                }
                else if (name_s === "id") {
                    jsonError.setId(value_s);
                }
                else if (name_s === "meta") {
                    const meta_any = value_any;
                    if (meta_any !== undefined && meta_any !== null) {
                        const meta = new JsonApiErrorMeta_1.JsonApiErrorMeta();
                        const meta_jo = meta_any;
                        const metaNames_ary = meta_jo.getNames();
                        jsonError.setMeta(meta);
                        metaNames_ary.forEach((metaName_s) => {
                            const metaValue_s = meta_jo.getString(metaName_s) || "";
                            if (metaName_s === JsonApiErrorMeta_1.JsonApiErrorMeta.metaData.jsonAttribute.endPoint) {
                                meta.setEndPoint(metaValue_s);
                            }
                            else if (metaName_s === JsonApiErrorMeta_1.JsonApiErrorMeta.metaData.jsonAttribute.errorType) {
                                meta.setErrorType(metaValue_s);
                            }
                            else if (metaName_s === JsonApiErrorMeta_1.JsonApiErrorMeta.metaData.jsonAttribute.i18nKey) {
                                meta.setI18nKey(metaValue_s);
                            }
                            else if (metaName_s === JsonApiErrorMeta_1.JsonApiErrorMeta.metaData.jsonAttribute.methodName) {
                                meta.setMethodName(metaValue_s);
                            }
                            else if (metaName_s === JsonApiErrorMeta_1.JsonApiErrorMeta.metaData.namespace) {
                                meta.setNamespace(metaValue_s);
                            }
                            else if (metaName_s === JsonApiErrorMeta_1.JsonApiErrorMeta.metaData.jsonAttribute.securityAttributeUUID) {
                                meta.setSecurityAttibuteUUID(metaValue_s);
                            }
                            else if (metaName_s === JsonApiErrorMeta_1.JsonApiErrorMeta.metaData.jsonAttribute.uiUUID) {
                                meta.setUIUUID(metaValue_s);
                            }
                        });
                    }
                }
                else if (name_s === "status") {
                    jsonError.setStatus(value_s);
                }
                else if (name_s === "title") {
                    jsonError.setTitle(value_s);
                }
            }
        }
        return (jsonError);
    }
    // Is this needed? Not used anywhere. commented out for now.
    // private setEntityValueFromAny(instanceObj: any, valueAny: any, attribute: Attribute | null | undefined): void {
    //     if(attribute === undefined || attribute === null) {
    //         throw new Error("attribute: Attribute is undefined or null");
    //     }
    //     EntityWebReflectionUtils.setValueFromAny(instanceObj, valueAny, attribute);
    // }
    setEntityValueFromJsonObject(instanceObj, jsonApiResourceObject, attribute) {
        if (attribute === undefined || attribute === null) {
            throw new Error("attribute: Attribute is undefined or null");
        }
        if (jsonApiResourceObject !== undefined && jsonApiResourceObject !== null) {
            EntityWebReflectionUtils_1.EntityWebReflectionUtils.setValueFromJsonObject(instanceObj, jsonApiResourceObject, attribute);
        }
    }
    /**
     *
     */
    getAsJsonApiBase(jsonApiResourceObject_jo) {
        let attribute = null;
        let dataType = null;
        let rootNewInstance = null;
        let entityWrapper = null;
        let id_any = null;
        let id_s = "";
        let type_any = null;
        let type_s = "";
        try {
            //let jsonApiPropertyNames_ary : Array<string> = jsonApiResourceObject_jo.getNames();
            // type
            type_any = jsonApiResourceObject_jo.get("type");
            if (type_any === null) {
                const json_s = JSON.stringify(jsonApiResourceObject_jo, null, 2);
                const error = new Error();
                const stackTrace = error.stack || '';
                const newError = new ErrorBase_1.ErrorBase(`type MUST exist, object missing type: ${json_s} \nstack trace: \n${stackTrace}`, NAMESPACE, this.getAsJsonApiBase.name, "0bee3f8e-8dbc-4d67-b38c-84776b9d2cbe");
                throw newError; // Error(NAMESPACE + "." + JsonApiToTypeScript.#getJsonApiResourceObjectMethodName + " type MUST exists.")
            }
            type_s = type_any;
            entityWrapper = EntityManager_1.EntityManager.getInstance().getEntityWrapperByNamespace(type_s);
            if (entityWrapper) {
                // JsonApiBase instance
                rootNewInstance = ClassFor_1.ClassFor.getInstance().getNew(type_s);
                if (rootNewInstance instanceof JsonApiPersistableBase_1.JsonApiPersistableBase) {
                    rootNewInstance._setIsMutateSuppressed(true);
                }
                // type
                attribute = entityWrapper.getAttributeByJsonTopLevelType();
                if (attribute) {
                    EntityWebReflectionUtils_1.EntityWebReflectionUtils.setEntityAttribute({ attribute: attribute, instanceObj: rootNewInstance, value: type_s });
                    // this.setEntityValueFromAny(rootNewInstance, type_s, attribute);
                }
                // id
                id_any = jsonApiResourceObject_jo.get("id");
                if (id_any !== null) {
                    id_s = id_any;
                    attribute = entityWrapper.getAttributeByJsonTopLevelID();
                    if (attribute) {
                        EntityWebReflectionUtils_1.EntityWebReflectionUtils.setEntityAttribute({ attribute: attribute, instanceObj: rootNewInstance, value: id_s });
                        //this.setEntityValueFromJsonObject(rootNewInstance, jsonApiResourceObject_jo, attribute);
                    }
                }
                if (type_s.indexOf("WorkspaceTemplateAttribute") > -1) {
                    const noop_b = true;
                }
                // attributes
                const attributes_jo = jsonApiResourceObject_jo.get("attributes");
                if (attributes_jo !== null) {
                    let attributesNames_ary = attributes_jo.getNames();
                    const indexMax_i = attributesNames_ary.length - 1;
                    let index_i = indexMax_i;
                    /**
                     * Need to put the names in reverse order. Class persistable methods need to be called first,
                     * then system variables. values that begin with '_' or '__' are system values.
                     *
                     **/
                    attributesNames_ary = attributesNames_ary.sort().reverse();
                    for (index_i = indexMax_i; index_i >= 0; index_i--) {
                        const attributeName_s = attributesNames_ary[index_i];
                        const value_any = attributes_jo.get(attributeName_s);
                        // for debugging purposes
                        // if(attributeName_s === '_relationshipPersistableType')
                        // {
                        //     let noop : any = null;
                        // }
                        attribute = entityWrapper.getAttributeByJsonAttributeName(attributeName_s);
                        if (attribute) {
                            EntityWebReflectionUtils_1.EntityWebReflectionUtils.setEntityAttribute({ attribute: attribute, instanceObj: rootNewInstance, value: value_any });
                            const attributeDataType = attribute.getDataType();
                            const getterMethodName_s = attribute.getTypeScriptGetterMethodName();
                            const setterMethodName_s = attribute.getTypeScriptSetterMethodName();
                            if (attributeDataType
                                && (attributeDataType === DataType_1.DataType.JSON_STRING)
                                && getterMethodName_s
                                && setterMethodName_s) {
                                // JSON_STRING returns an Object
                                let object_any = rootNewInstance[getterMethodName_s]();
                                // turn the Object into a string
                                const temp_s = JSON.stringify(object_any);
                                // Going from TypeScript to JsonApi it was encoded via encodeURI, so need to decodeURI
                                // temp_s     = decodeURI(temp_s);
                                // turn it back into and object
                                object_any = JSON.parse(temp_s);
                                // put it back in.
                                rootNewInstance[setterMethodName_s](object_any);
                            }
                        }
                    }
                }
                // 'relationships' ---
                const relationships_jo = jsonApiResourceObject_jo.get("relationships");
                if (relationships_jo !== null) {
                    const relationshipNames_ary = relationships_jo.getNames();
                    for (let index_i = 0; index_i < relationshipNames_ary.length; index_i++) {
                        const relationshipName_s = relationshipNames_ary[index_i];
                        const relationshipEntity_jo = relationships_jo.get(relationshipName_s);
                        if (relationshipEntity_jo !== null) {
                            // is the attribute to identifes that two entities are related.
                            const relationshipAttribute = entityWrapper.getAttributeByJsonAttributeName(relationshipName_s);
                            if (relationshipAttribute !== null) {
                                dataType = relationshipAttribute.getDataType();
                                const relationshipNames_ary = relationshipEntity_jo.getNames();
                                for (let relIndex_i = 0; relIndex_i < relationshipNames_ary.length; relIndex_i++) {
                                    const relationshipName = relationshipNames_ary[relIndex_i];
                                    // 'data' ---
                                    if (relationshipName === "data") {
                                        const relationshipData_ja = relationshipEntity_jo.get("data");
                                        if (relationshipData_ja !== null) {
                                            if (dataType !== undefined && dataType !== null) {
                                                switch (dataType) {
                                                    case DataType_1.DataType.MONGO_REF:
                                                    case DataType_1.DataType.MANY_TO_ONE:
                                                        // eslint-disable-next-line
                                                        let item_jo = relationshipData_ja.get(0);
                                                        if (item_jo !== null) {
                                                            const item_jab = this.getAsJsonApiBase(item_jo);
                                                            if (item_jab) {
                                                                EntityWebReflectionUtils_1.EntityWebReflectionUtils.setEntityAttribute({ attribute: relationshipAttribute, instanceObj: rootNewInstance, value: item_jab });
                                                                //this.setEntityValueFromAny(rootNewInstance, item_jab, relationshipAttribute);
                                                            }
                                                        }
                                                        break;
                                                    case DataType_1.DataType.MONGO_REF_ARRAY:
                                                    case DataType_1.DataType.MONGO_VIRTUAL_ARRAY:
                                                    case DataType_1.DataType.ONE_TO_MANY:
                                                        // eslint-disable-next-line
                                                        let arraySize_i = relationshipData_ja.size();
                                                        for (let arrayIndex_i = 0; arrayIndex_i < arraySize_i; arrayIndex_i++) {
                                                            const arrayItem_jo = relationshipData_ja.get(arrayIndex_i);
                                                            const arrayItem_jab = this.getAsJsonApiBase(arrayItem_jo);
                                                            if (arrayItem_jab) {
                                                                EntityWebReflectionUtils_1.EntityWebReflectionUtils.setEntityAttribute({ attribute: relationshipAttribute, instanceObj: rootNewInstance, value: arrayItem_jab });
                                                            }
                                                        }
                                                        break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (rootNewInstance instanceof JsonApiPersistableBase_1.JsonApiPersistableBase) {
                    rootNewInstance._setIsMutateSuppressed(false);
                }
            }
            else {
                const newError = new ErrorBase_1.ErrorBase(`EntityWrapper for type: '${type_s}' MUST exists.`, NAMESPACE, this.getAsJsonApiBase.name, "56605c5c-3805-46e8-a84f-2ef7a3db1666");
                throw newError; //new Error(NAMESPACE + "." + JsonApiToTypeScript.#getJsonApiResourceObjectMethodName + " EntityWrapper for type: '" + type_s + "' MUST exists.");
            }
        }
        catch (error_any) {
            const error = error_any;
            LOGGER.logError({ message: `${error.message} ${error.stack}`, methodName: this.getAsJsonApiBase.name, uuid: '568d2e44-4031-4318-9fd3-3ed710cb9924' });
            // let errorBase: ErrorBase = new ErrorBase(error.message, NAMESPACE, this.getAsJsonApiBase.name, "568d2e44-4031-4318-9fd3-3ed710cb9924", error);
            // if(LOGGER.isErrorEnabled()) { LOGGER.logErrorBase(errorBase); }
        }
        if (this.clearAllMutatedFlags_b) {
            if (rootNewInstance !== null && rootNewInstance !== undefined && rootNewInstance instanceof JsonApiPersistableBase_1.JsonApiPersistableBase) {
                const japb = rootNewInstance;
                japb._clearIsMutated();
            }
        }
        return (rootNewInstance);
    }
    /**
     *
     */
    jsonObjectToJsonApiDocument(jsonApiDocument_jo_p) {
        this.initJsonApiDocumentTopLevel(jsonApiDocument_jo_p);
        return (this.jsonApiDocument_c);
    }
}
exports.JsonApiToTypeScript = JsonApiToTypeScript;
//# sourceMappingURL=JsonApiToTypeScript.js.map