"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityStateManager = exports.JsonApiPersistableBase = void 0;
const PersistenceType_1 = require("../data/PersistenceType");
const LogManager_1 = require("../utils/log/LogManager");
const JsonApiBase_1 = require("./JsonApiBase");
const log_1 = require("../utils/log");
/**
 {
  "jsonStateStr":
  {
    "attributes": [
      {
        "name": "_relationshipPersistableType",
        "isMutated": true
      },
      {
        "name": "description",
        "isMutated": true
      }
    ],
    "persistableType": 1
  }
}
 */
function deepEquals(obj1, obj2, seen = new WeakMap()) {
    if (obj1 === obj2)
        return true; // Same reference
    if (typeof obj1 !== "object" || typeof obj2 !== "object" || obj1 === null || obj2 === null) {
        return obj1 === obj2; // Primitive values or one is null
    }
    // Handle circular references
    if (seen.has(obj1) && seen.get(obj1) === obj2) {
        return true;
    }
    seen.set(obj1, obj2);
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length)
        return false; // Different number of keys
    for (let key of keys1) {
        if (!keys2.includes(key) || !deepEquals(obj1[key], obj2[key], seen)) {
            return false;
        }
    }
    return true;
}
class MongoAttributes {
    constructor() {
        this._entityState = "_entityState";
        this._idSetBySystem = "_idSetBySystem";
        this._initializedDataKey = "_initializedDataKey";
        this._id = "_id";
        this.jsonType = "jsonType";
        this.modifiedDate = "modifiedDate";
    }
}
class MetaData {
    constructor() {
        this.namespace = "com.salesstryke.jsonApi.JsonApiPersistableBase";
        this.mongoAttributes = new MongoAttributes();
    }
}
const NAMESPACE = "com.salesstryke.jsonApi.JsonApiPersistableBase";
const LOGGER = LogManager_1.LogManager.getLogger(NAMESPACE);
LOGGER.setLogLevel(log_1.Level.INFO);
class JsonApiPersistableBase extends JsonApiBase_1.JsonApiBase {
    constructor(p) {
        super();
        this._entityState = null;
        /**
         * Identifies if the given Entity has been persisted during the current save.
         */
        this._hasBeenPersisted_b = false;
        this._isUserSetId_b = false;
        this._isMutateSuppressed_b = false;
        /**
         * In a transaction, while persisting, we want to prevent an infinite loop of a child attempting to save the parent, that saves the child that saves the parent  ....
         *
         */
        this._isPersistTraversalComplete = false;
        this._savedMongoDoc_any = null;
        this.createdDate = null;
        this.modifiedDate = null;
        this.entityStateAuditor = new EntityStateManager({ entity: this });
        if (p) {
            if (p && p.isTrackingMutations) {
                this._trackMutations();
            }
        }
        //let _entity : Array<JsonApiBase> | undefined = Clone.cloneEntityArray<JsonApiBase>({ jsonApiBase : [this] });
    }
    _getHashCode2() {
        return (-1);
    }
    _getIsPersistTraversalComplete() {
        return (this._isPersistTraversalComplete);
    }
    /**
     * Did the user set the id.
     * @returns
     */
    _getIsUserSetId() {
        return (this._isUserSetId_b);
    }
    /**
     * ```
     * For relationships:
     *    MONGO_REF,
     *    MONGO_REF_ARRAY,
     *    MANY_TO_MANY,
     *    MANY_TO_ONE,
     *    ONE_TO_MANY,
     *    ONE_TO_ONE, identifies if the value is to be:
     *
     *    ATTACH         = 10:  identifies to attach an existing Entity by id to a MONGO_REF_ARRAY
     *    CREATE         = 20:  identifies to create a MONGO_REF is it does not contain an ObjectId.
     *    UPDATE         = 30:  identifies if the system is to update a MONGO_REF that is a member of an Entity.
     *    DETACH         = 40:  identifies to detach an existing Entity by id from a MONGO_REF_ARRY.
     *    DELETE         = 50:  identifies to delete a MONGO_REF if allowed.
     *    DELETE_CASCADE = 60:  identifies to cascase delete MONGO_REF items if allowed.
     * ```
     */
    _getRelationshipPersistableType() {
        return (this._relationshipPersistableType);
    }
    _getSavedMongoDoc() {
        return (this._savedMongoDoc_any);
    }
    /**
     * Sets all isMutated flags to be false.
     * @param isMutated_b
     * @returns
     */
    _clearIsMutated() {
        return (this);
    }
    getClassName() {
        return ("com.salesstryke.jsonapi.JsonApiPersistableBase");
    }
    getCreatedDate() {
        return (this.createdDate);
    }
    getId() {
        return (null);
    }
    getModifiedDate() {
        return (this.modifiedDate);
    }
    /**
     * CREATE, DELETE, UPDATE
     * @returns string | null
     */
    _getEntityState() {
        return (this._entityState);
    }
    _getHasBeenPersisted() {
        return (this._hasBeenPersisted_b);
    }
    /**
     * This is a key that is used to initialize data one time. Example: setting the USState information.
     * @returns string | null
     */
    _getInitializedDataKey() {
        return (null);
    }
    /**
     * If this Entity is in an array, setting this to true indicates that the value will be persisted as part of the
     * array, if false, will not be persisted as part of the array.
     * @returns
     */
    _getIsAddToRelationship() {
        return (false);
    }
    /**
     * Indicates if the ID was set by the system and that the ID is used to create the documet.
     */
    _getIsIdSetBySystem() {
        return (false);
    }
    _getIsMutateSuppressed() {
        return (this._isMutateSuppressed_b);
    }
    _getIsRemoveFromRelationship() {
        return (false);
    }
    static getSimpleName() {
        return ("JsonApiPersistableBase");
    }
    /**
     * CREATE, DELETE, UPDATE
     */
    _setEntityState(_entityState) {
        this._entityState = _entityState;
        return (this);
    }
    setCreatedDate(createdDate) {
        this.createdDate = createdDate;
        return (this);
    }
    setModifiedDate(modifiedDate) {
        this.modifiedDate = modifiedDate;
        return (this);
    }
    _setHasBeenPersisted(hasBeenPersisted_b) {
        this._hasBeenPersisted_b = hasBeenPersisted_b;
        return (this);
    }
    /**
     * Did the user set the id.
     * @returns
     */
    _setIsUserSetId(isUserSetId) {
        this._isUserSetId_b = isUserSetId;
        return (this);
    }
    setId(id) {
        return (this);
    }
    /**
     * This is a key that is used to initialize data one time. Example: setting the USState information.
     */
    _setInitializedDataKey(initializedDataKey) {
        return (this);
    }
    _isMutated(p) {
        let isMutated = !deepEquals(p.obj0, p.obj1);
        return (isMutated);
    }
    _getInitialAttributeState(p) {
        let value_any = null;
        value_any = this._initialAttributeState_map.get(p.name);
        return (value_any);
    }
    _getIsMutatedFromMap() {
        return (this._isMutatedFromMap);
    }
    _setInitialAttributesState() {
        this._isMutatedFromMap = true;
        return (this);
    }
    /**
     * Used to track the initial state of an Attribute. Is used to identify if an attribute has mutated.
     * @param p
     * @returns
     */
    _setInitialAttributeState(p) {
        let clone = structuredClone(p.value);
        this._initialAttributeState_map.set(p.name, clone);
        return (this);
    }
    _setIsAddToRelationship(value_b) {
        return (this);
    }
    /**
     * Indicates if the ID was set by the system and that the ID is used to create the documet.
     */
    _setIsIdSetBySystem(_idSetBySystem) {
        return (this);
    }
    _setIsMutateSuppressed(_isMutateSuppressed_b) {
        this._isMutateSuppressed_b = _isMutateSuppressed_b;
        return (this);
    }
    _setIsPersistTraversalComplete(isPersistTraversalComplete) {
        this._isPersistTraversalComplete = isPersistTraversalComplete;
        return (this);
    }
    _setIsRemoveFromRelationship(value_b) {
        return (this);
    }
    /**
     * ```
     * For relationships:
     *    MONGO_REF,
     *    MONGO_REF_ARRAY,
     *    MANY_TO_MANY,
     *    MANY_TO_ONE,
     *    ONE_TO_MANY,
     *    ONE_TO_ONE, identifies if the value is to be:
     *
     *    ATTACH         = 10:  identifies to attach an existing Entity by id to a MONGO_REF_ARRAY
     *    CREATE         = 20:  identifies to create a MONGO_REF is it does not contain an ObjectId.
     *    UPDATE         = 30:  identifies if the system is to update a MONGO_REF that is a member of an Entity.
     *    DETACH         = 40:  identifies to detach an existing Entity by id from a MONGO_REF_ARRY.
     *    DELETE         = 50:  identifies to delete a MONGO_REF if allowed.
     *    DELETE_CASCADE = 60:  identifies to cascase delete MONGO_REF items if allowed.
     * ```
     */
    _setRelationshipPersistableType(relationshipPersistableType) {
        this._relationshipPersistableType = relationshipPersistableType;
        return (this);
    }
    _setSavedMongoDoc(savedMongoDoc_any) {
        this._savedMongoDoc_any = savedMongoDoc_any;
        return (this);
    }
}
exports.JsonApiPersistableBase = JsonApiPersistableBase;
JsonApiPersistableBase.metaDataForJsonApiPersistableBase = new MetaData();
class ItemAudit {
    constructor(p) {
        this.audit_ary = new Array();
        this.initialState = p.itemValue;
        this.initialPersistenceType = p.persistenceType;
    }
    getInitialState() {
        return (this.initialState);
    }
    getInitialPersistenceType() {
        return (this.initialPersistenceType);
    }
}
class AttributeState {
    constructor(p) {
        this.attributeDataType = undefined;
        this.attributeTypeReference = undefined;
        // The attribute array at the begining of the audit. This is a clone
        this.initialAttributeValueAry = new Array();
        // The attribute array values 
        this.activeAttributeValueAry = new Array();
        this.itemAudit_map = new Map();
        this.removedAttributeValueAry = new Array();
        // MongoRef
        this.mongoRefActiveState_ary = new Array;
        this.mongoRefInitialState_ary = new Array;
        this.attributeDataType = (p.dataType ? p.dataType : undefined);
        this.attributeName = p.attributeName;
        this.attributeTypeReference = (p.typeReference ? p.typeReference : undefined);
        this.entity = p.entity;
        let entity_any = this.entity;
        if (p.mongoRefInitialState) {
            this.mongoRefActiveState_ary = p.mongoRefInitialState;
            this.mongoRefInitialState_ary = this.getCloneObject({ object: p.mongoRefInitialState });
        }
        let active = entity_any[this.attributeName];
        //this.initialAttributeValueAry = Clone.cloneEntityArray<JsonApiPersistableBase>({ jsonApiBase : this.initialAttributeValueAry });
        //  this.activeAttributeValueAry  = p.attributeValueAry; 
        //  this.initialAttributeValueAry = this.getClone({ entities : p.attributeValueAry });
        let noop = 0;
    }
    deepEqual(p) {
        if (p.obj1 === p.obj2) {
            return true;
        }
        if (p.obj1 === null || p.obj2 === null || typeof p.obj1 !== 'object' || typeof p.obj2 !== 'object') {
            return false;
        }
        const keys1 = Object.keys(p.obj1);
        const keys2 = Object.keys(p.obj2);
        if (keys1.length !== keys2.length) {
            return false;
        }
        for (let key of keys1) {
            if (!keys2.includes(key) || !this.deepEqual({ obj1: p.obj1[key], obj2: p.obj2[key] })) {
                return false;
            }
        }
        return true;
    }
    getCloneArray(p) {
        let cloneEntites = new Array();
        let index_i = 0;
        let size_i = p.entities.length;
        for (index_i = 0; index_i < size_i; index_i++) {
            let entity = p.entities[index_i];
            let clone_any = Object.assign(Object.create(Object.getPrototypeOf(entity)), entity);
            let clone_japb = clone_any;
            cloneEntites.push(clone_japb);
        }
        return (cloneEntites);
    }
    getCloneObject(p) {
        let clone = undefined;
        clone = Object.assign(Object.create(Object.getPrototypeOf(p.object)), p.object);
        return (clone);
    }
    getDataType() {
        return (this.attributeDataType);
    }
    /**
     * TODO: check, then delete.
     * @returns
     */
    getHashCode() {
        return (-1);
    }
    getItemPreviousState(p) {
        let index_i = 0;
        let previousState = undefined;
        let removeEntity_b = (p.removeEntity ? p.removeEntity : false);
        let replaceEntity_b = (p.replaceEntity ? p.replaceEntity : false);
        index_i = p.attributeValues.indexOf(p.arrayItem);
        if (index_i >= 0) {
            previousState = p.attributeValues[index_i];
            this.removeReplaceEntity({ attributeValues: p.attributeValues, entity: p.arrayItem, index: index_i, removeEntity: removeEntity_b, replaceEntity: replaceEntity_b });
            return (previousState);
        }
        let id_s = p.arrayItem.getId();
        if (id_s) {
            index_i = this.initialAttributeValueAry.findIndex(obj => obj.getId() === id_s);
            previousState = this.initialAttributeValueAry.find(obj => obj.getId() === id_s);
            if (previousState) {
                this.removeReplaceEntity({ attributeValues: p.attributeValues, entity: p.arrayItem, index: index_i, removeEntity: removeEntity_b, replaceEntity: replaceEntity_b });
                return (previousState);
            }
        }
        index_i = this.initialAttributeValueAry.findIndex(item => this.deepEqual({ obj1: item, obj2: p.arrayItem }));
        previousState = this.initialAttributeValueAry.find(item => this.deepEqual({ obj1: item, obj2: p.arrayItem }));
        if (previousState) {
            this.removeReplaceEntity({ attributeValues: p.attributeValues, entity: p.arrayItem, index: index_i, removeEntity: removeEntity_b, replaceEntity: replaceEntity_b });
        }
        return (previousState);
    }
    removeReplaceEntity(p) {
        if (p.removeEntity || p.replaceEntity) {
            p.attributeValues.splice(p.index, 1);
            if (p.replaceEntity) {
                p.attributeValues.push(p.entity);
            }
        }
    }
    getPersistenceType(p) {
        let persistableType_n = p.entity._getRelationshipPersistableType();
        let entityPersistableType = PersistenceType_1.PersistenceType.ATTACH.getById({ id: persistableType_n });
        return (entityPersistableType);
    }
    setPersistanceType(p) {
        if (p.persistenceType === PersistenceType_1.PersistenceType.ATTACH) {
            p.entity._setIsAddToRelationship(true);
            p.entity._setIsRemoveFromRelationship(false);
        }
        else if (p.persistenceType === PersistenceType_1.PersistenceType.DETACH) {
            p.entity._setIsAddToRelationship(false);
            p.entity._setIsRemoveFromRelationship(true);
        }
    }
    /**
     *
     * @param p
     */
    setState(p) {
        let item = p.relation;
        //let hashCode           : number                        = item.getHashCode();
        //   let attributeValue_ary : Array<JsonApiPersistableBase> = this.initialAttributeValueAry as Array<JsonApiPersistableBase>;
        let initialItemState = this.getItemPreviousState({ attributeValues: this.initialAttributeValueAry, arrayItem: p.relation });
        let activeItemState = this.getItemPreviousState({ attributeValues: this.activeAttributeValueAry, arrayItem: p.relation });
        let entityPersistableType = this.getPersistenceType({ entity: p.relation });
        let noop = 0;
        if (initialItemState) {
            let entityInitialPersistenceType = this.getPersistenceType({ entity: initialItemState });
            if (activeItemState) {
                if (entityInitialPersistenceType === entityPersistableType) {
                    // do nothing.
                }
                else {
                    this.getItemPreviousState({ attributeValues: this.activeAttributeValueAry, arrayItem: p.relation, removeEntity: true, replaceEntity: true });
                }
            }
        }
        else {
            // Was not in data that would be returned from a query.
            // check if this is a duplicate of a value already in the active state.
            // if(activeItemState)
            // {
            // }
            // else 
            // {
            //     // first time entity has been added
            //     noop = 0;
            // }
            noop = 0;
        }
        if (!activeItemState) {
            //let className : string = p.entity.getClassName();
            this.activeAttributeValueAry.push(p.relation);
        }
    }
    setMongoRefState(p) {
        let activeItemState = this.getItemPreviousState({ attributeValues: this.mongoRefActiveState_ary, arrayItem: p.item });
        let initialItemState = this.getItemPreviousState({ attributeValues: this.mongoRefInitialState_ary, arrayItem: p.item });
        if (!p.isMutateSuppresed) {
            this.setPersistanceType({
                entity: p.item,
                persistenceType: p.persistanceType
            });
        }
        // if(initialItemState)
        // {
        // }
        if (!initialItemState) {
            // if(activeItemState)
            // {
            // }
            if (!activeItemState) {
                this.mongoRefActiveState_ary.push(p.item);
            }
        }
    }
}
const NAMESPACE2 = "com.salesstryke.jsonApi.JsonApiPersistableBase:EntityStateManager";
const LOGGER2 = LogManager_1.LogManager.getLogger(NAMESPACE2);
LOGGER2.setLogLevel(log_1.Level.OFF);
/*
    public addRole(role: SecurityRole, persistanceType: PersistenceType = PersistenceType.ATTACH): SecureIdentity {
        
        //if(!this._getIsMutateSuppressed()) { role._setRelationshipPersistableType(persistanceType.getId()); this._setIsRolesMutated(true); }
        this.entityStateAuditor.attachMongoRefItem({
            attributeName      : 'roles',
            dataType           : DataType.MONGO_REF,
            initialActiveState : this.roles,
            isMutateSuppresed  : this._getIsMutateSuppressed(),
            item               : role,
            persistanceType    : persistanceType
        });
        //PersistableUtils.addOrReplaceInArray(this.roles, role, persistanceType);
        return(this);
    }
*/
/**
 * TODO: deprecate this.
 * An entity can have many attributes. An Attribute can have a single value or an Array of values.
 */
class EntityStateManager {
    constructor(p) {
        /**
         * string is attributeName.
         */
        this.attributeAuditByAttributeName_map = new Map();
        this.entity = p.entity;
        // CHECK VALUES EXIST
        let attributeExists_b = false;
        this.attributeExistsOrThrow({ checkAttributeName: '_isMutateSuppressed_b' });
        this.attributeExistsOrThrow({ checkAttributeName: '_relationshipPersistableType' });
    }
    attributeExistsOrThrow(p) {
        let attributeExists_b = false;
        let entity_any = this.entity;
        let att_any = entity_any[p.checkAttributeName];
        if (!entity_any[p.checkAttributeName]) {
            let className = this.entity.getClassName();
            LOGGER2.logError({ message: `${className} attribute missing : ${p.checkAttributeName}` + p.checkAttributeName, methodName: this.attributeExistsOrThrow.name });
        }
    }
    addRelationship(p) {
        let attributeAudit = undefined;
        attributeAudit = this.attributeAuditByAttributeName_map.get(p.attributeName);
        if (attributeAudit) {
            attributeAudit.setState({ relation: p.relation, persistenceType: p.persistanceType });
            return;
        }
        else {
            attributeAudit = new AttributeState({ attributeName: p.attributeName, entity: this.entity });
            attributeAudit.setState({ relation: p.relation, persistenceType: p.persistanceType });
            this.attributeAuditByAttributeName_map.set(p.attributeName, attributeAudit);
            return;
        }
    }
    attachMongoRefItem(p) {
        this.initializeAttributeState({
            attributeName: p.attributeName,
            dataType: (p.dataType ? p.dataType : undefined),
            mongoRefInitialState: p.initialActiveState,
            typeReference: (p.typeReference ? p.typeReference : undefined)
        });
        let attributeState = undefined;
        attributeState = this.attributeAuditByAttributeName_map.get(p.attributeName);
        if (attributeState) {
            attributeState.setMongoRefState({ isMutateSuppresed: p.isMutateSuppresed, item: p.item, persistanceType: p.persistanceType });
        }
    }
    clear() {
        this.attributeAuditByAttributeName_map.clear();
    }
    clearIsMutated() {
        let attributeStates = Array.from(this.attributeAuditByAttributeName_map.values());
        let index_i = 0;
        let size_i = attributeStates.length;
        for (index_i = 0; index_i < size_i; index_i++) {
            let attribute = attributeStates[index_i];
            let dataType = attribute.getDataType();
            // if(dataType)
            // {
            //     switch(dataType)
            //     {
            //     }
            // }
        }
    }
    // public detachMongoRefItem(): void 
    // {
    // }
    initializeAttributeState(p) {
        let attributeState = undefined;
        attributeState = this.attributeAuditByAttributeName_map.get(p.attributeName);
        if (!attributeState) {
            attributeState = new AttributeState({
                attributeName: p.attributeName,
                dataType: (p.dataType ? p.dataType : undefined),
                entity: this.entity,
                mongoRefInitialState: (p.mongoRefInitialState ? p.mongoRefInitialState : undefined),
                typeReference: (p.typeReference ? p.typeReference : undefined)
            });
            this.attributeAuditByAttributeName_map.set(p.attributeName, attributeState);
            return;
        }
    }
}
exports.EntityStateManager = EntityStateManager;
//# sourceMappingURL=JsonApiPersistableBase.js.map