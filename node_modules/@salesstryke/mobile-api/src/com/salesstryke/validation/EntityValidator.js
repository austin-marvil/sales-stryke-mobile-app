"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityValidator = void 0;
const data_1 = require("../data");
const persistable_1 = require("../entity/classes/persistable");
const I18nLocaleTypeEnum_1 = require("../entity/enums/I18nLocaleTypeEnum");
const util_1 = require("../jsonApi/util");
const ErrorBase_1 = require("../lang/ErrorBase");
const LogManager_1 = require("../utils/log/LogManager");
const IsString_1 = require("../utils/object/IsString");
const NAMESPACE = "com.salesstryke.validation.EntityValidator";
const LOGGER = LogManager_1.LogManager.getLogger(NAMESPACE);
class EntityValidator {
    /**
     * ```
     *
     *  entityValidatorName : An optional name for this EntityValidator.
     * ```
     * @param p
     */
    constructor(p) {
        this.entityValidatorName = null;
        this.locale_s = null;
        this.validatorErrors = new Array();
        this.validators_map = new Map();
        if (p.entityValidatorName) {
            this.entityValidatorName = p.entityValidatorName;
        }
        this.entity = p.entity;
        this.setLocale({ locale: p.locale ? p.locale : I18nLocaleTypeEnum_1.I18nLocaleTypeEnum.EN_US });
        // We need to get the cloned validators.
        let entityWrapper = null;
        let namespace_s = this.entity.getClassName();
        entityWrapper = data_1.EntityManager.getInstance().getEntityWrapperByNamespace(namespace_s);
        if (!entityWrapper) {
            return;
        }
        let validatorAttributes = entityWrapper.getValidatorAttributes();
        let index_i = 0;
        let size_i = validatorAttributes.length;
        for (index_i = 0; index_i < size_i; index_i++) {
            let attribute = validatorAttributes[index_i];
            let attribteName = attribute.getTypeScriptAttributeName();
            let attributeUUID = attribute.getUUID();
            let validatorOrig = attribute.getValidator();
            let validatorClone = null;
            if (!validatorOrig) {
                continue;
            }
            validatorClone = validatorOrig.getClone();
            if (!validatorClone) {
                continue;
            }
            if (attribteName) {
                validatorClone.setAttributeName({ attributeName: attribteName });
                validatorClone.setAttributeUUID({ attributeUUID: attributeUUID });
            }
            this.validators_map.set(attribteName, validatorClone);
        }
    }
    /**
     * The optional name of this EntityValidator
     * @returns
     */
    getEntityValidatorName() {
        return (this.entityValidatorName);
    }
    getValidatorByAttributeName(p) {
        let validator = null;
        let temp = this.validators_map.get(p.attributeName);
        if (temp) {
            validator = temp;
        }
        return (validator);
    }
    getValidatorErrors() {
        return (this.validatorErrors);
    }
    isValid() {
        let isValid_b = false;
        let namespace_s = this.entity.getClassName();
        let entityWrapper = data_1.EntityManager.getInstance().getEntityWrapperByNamespace(namespace_s);
        if (entityWrapper) {
            let validatorAttributes = entityWrapper.getValidatorAttributes();
            let index_i = 0;
            let size_i = validatorAttributes.length;
            for (index_i = 0; index_i < size_i; index_i++) {
                let attribute = validatorAttributes[index_i];
                let attribteName = attribute.getTypeScriptAttributeName();
                let attributeUUID = attribute.getUUID();
                let validator = attribute.getValidator();
                let value = util_1.EntityWebReflectionUtils.getValue(attribute, this.entity);
                if (!validator) {
                    continue;
                }
                if (!this.locale_s) {
                    throw new ErrorBase_1.ErrorBase(`${this.constructor.name} this.locale is null.`, NAMESPACE, this.isValid.name);
                }
                validator.setLocale({ locale: this.locale_s });
                validator.setValue({ value: value });
                if (attribteName) {
                    validator.setAttributeName({ attributeName: attribteName });
                    validator.setAttributeUUID({ attributeUUID: attributeUUID });
                }
                if (!validator.isValid()) {
                    this.validatorErrors.push(validator);
                }
            }
        }
        if (this.validatorErrors.length === 0) {
            isValid_b = true;
        }
        return (isValid_b);
    }
    setLocale(p) {
        if (p.locale) {
            if (p.locale instanceof persistable_1.I18nLocaleType) {
                let i18nLocaleType = p.locale;
                this.locale_s = i18nLocaleType.getName() || '';
            }
            else if (p.locale instanceof I18nLocaleTypeEnum_1.I18nLocaleTypeEnum) {
                let i18nLocaleTypeEnum = p.locale;
                this.locale_s = i18nLocaleTypeEnum.getName();
            }
            else if ((0, IsString_1.default)(p.locale)) {
                this.locale_s = p.locale;
            }
        }
        if (!this.locale_s) {
            this.locale_s = I18nLocaleTypeEnum_1.I18nLocaleTypeEnum.EN_US.getName();
        }
    }
}
exports.EntityValidator = EntityValidator;
//# sourceMappingURL=EntityValidator.js.map