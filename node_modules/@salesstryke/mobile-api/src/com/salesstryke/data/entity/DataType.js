"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataType = void 0;
const EnumBase_1 = require("../../lang/EnumBase");
/**
 * You can NOT just add a new DataType and expect it to work, there are other
 * places in the code that MUST validate a DataType.
 */
const NAMESPACE = 'com.salesstryke.data.entity.DataType';
class DataType extends EnumBase_1.EnumBase {
    constructor(p) {
        super({ name: p.name, namespace: NAMESPACE });
        this.mongooseSchemaType = p.mongooseSchemaType;
        this.typeScriptType = p.typeScriptType;
    }
    getMongooseSchemaType() {
        return (this.mongooseSchemaType);
    }
    getTypeScriptType() {
        return (this.typeScriptType);
    }
}
exports.DataType = DataType;
DataType.BOOLEAN = new DataType({ name: 'BOOLEAN', mongooseSchemaType: 'Boolean', typeScriptType: 'boolean' });
DataType.CURRENCY = new DataType({ name: 'CURRENCY', mongooseSchemaType: 'Number', typeScriptType: 'number' });
DataType.DATE = new DataType({ name: 'DATE', mongooseSchemaType: 'Date', typeScriptType: 'Date' });
DataType.FLOAT = new DataType({ name: 'FLOAT', mongooseSchemaType: 'Number', typeScriptType: 'number' });
DataType.FORIEGN_KEY = new DataType({ name: 'FORIEGN_KEY', mongooseSchemaType: 'Schema.Types.ObjectId', typeScriptType: null });
DataType.ID = new DataType({ name: 'ID', mongooseSchemaType: 'Schema.Types.ObjectId', typeScriptType: 'string' });
DataType.INTEGER = new DataType({ name: 'INTEGER', mongooseSchemaType: 'Number', typeScriptType: 'number' });
/**
 * For a JsonApi, a setter method will take in a JSON object, JSON.stringify it then that is used as the value.
 * When using a getter method, the Json string will turned into a JSON object using JSON.parse
 */
DataType.JSON_STRING = new DataType({ name: 'JSON_STRING', mongooseSchemaType: 'String', typeScriptType: 'string' });
DataType.NUMBER = new DataType({ name: 'NUMBER', mongooseSchemaType: 'Number', typeScriptType: 'number' });
DataType.MANY_TO_MANY = new DataType({ name: 'MANY_TO_MANY', mongooseSchemaType: 'Schema.Types.ObjectId', typeScriptType: null });
DataType.MANY_TO_ONE = new DataType({ name: 'MANY_TO_ONE', mongooseSchemaType: 'Schema.Types.ObjectId', typeScriptType: null });
/**
 * logically a ManyToOne
 */
DataType.MONGO_REF = new DataType({ name: 'MONGO_REF', mongooseSchemaType: 'Schema.Types.ObjectId', typeScriptType: null });
/**
 * Logicall a ManyToMany, Holds an Array of ObjectId's.
 */
DataType.MONGO_REF_ARRAY = new DataType({ name: 'MONGO_REF_ARRAY', mongooseSchemaType: 'Schema.Types.ObjectId', typeScriptType: null });
/**
 * logically a OneToMany
 */
DataType.MONGO_VIRTUAL_ARRAY = new DataType({ name: 'MONGO_VIRTUAL_ARRAY', mongooseSchemaType: 'Schema.Types.ObjectId', typeScriptType: null });
/**
 * for record type
 */
DataType.ONE_TO_MANY = new DataType({ name: 'ONE_TO_MANY', mongooseSchemaType: 'Schema.Types.ObjectId', typeScriptType: null });
DataType.REAL = new DataType({ name: 'REAL', mongooseSchemaType: 'Number', typeScriptType: 'number' });
/**
 * To prevent data from getting out of the system.
 */
DataType.SECURE_STRING = new DataType({ name: 'SECURE_STRING', mongooseSchemaType: 'String', typeScriptType: 'string' });
DataType.STRING = new DataType({ name: 'STRING', mongooseSchemaType: 'String', typeScriptType: 'string' });
//# sourceMappingURL=DataType.js.map