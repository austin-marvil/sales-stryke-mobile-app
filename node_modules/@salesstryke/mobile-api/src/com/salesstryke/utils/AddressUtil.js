"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressUtil = exports.addressLevelConversion = exports.AddressValidatorService = exports.SubpremiseLevelList = exports.streetSuffix = exports.streetDirection = void 0;
const validation_1 = require("./validation");
exports.streetDirection = {
    "N": [
        "N",
        "NORTH",
    ],
    "S": [
        "S",
        "SOUTH",
    ],
    "W": [
        "W",
        "WEST",
    ],
    "E": [
        "E",
        "EAST",
    ],
};
exports.streetSuffix = {
    "ALY": [
        "ALLEY",
        "ALLEE",
        "ALLY"
    ],
    "ANX": [
        "ANEX",
        "ANNEX",
        "ANNX"
    ],
    "ARC": [
        "ARCADE"
    ],
    "AVE": [
        "AVENUE",
        "AV",
        "AVEN",
        "AVENU",
        "AVN",
        "AVNUE"
    ],
    "BYU": [
        "BAYOU",
        "BAYOO"
    ],
    "BCH": [
        "BEACH"
    ],
    "BND": [
        "BEND"
    ],
    "BLF": [
        "BLUFF",
        "BLUF"
    ],
    "BLFS": [
        "BLUFFS"
    ],
    "BTM": [
        "BOTTOM",
        "BOT",
        "BOTTM"
    ],
    "BLVD": [
        "BOULEVARD",
        "BOUL",
        "BOULV"
    ],
    "BR": [
        "BRANCH",
        "BRNCH"
    ],
    "BRG": [
        "BRIDGE",
        "BRDGE"
    ],
    // Not valid for softpak
    // "BRK": [
    // 	"BROOK"
    // ],
    // "BRKS": [
    // 	"BROOKS"
    // ],
    "BG": [
        "BURG"
    ],
    "BGS": [
        "BURGS"
    ],
    "BYP": [
        "BYPASS",
        "BYPA",
        "BYPAS",
        "BYPS"
    ],
    "CP": [
        "CAMP",
        "CMP"
    ],
    "CYN": [
        "CANYON",
        "CANYN",
        "CNYN"
    ],
    "CPE": [
        "CAPE"
    ],
    "CSWY": [
        "CAUSEWAY",
        "CAUSWA"
    ],
    "CTR": [
        "CENTER",
        "CEN",
        "CENT",
        "CENTR",
        "CENTRE",
        "CNTER",
        "CNTR"
    ],
    "CTRS": [
        "CENTERS"
    ],
    "CIR": [
        "CIRCLE",
        "CIRC",
        "CIRCL",
        "CRCL",
        "CRCLE"
    ],
    "CIRS": [
        "CIRCLES"
    ],
    "CLF": [
        "CLIFF"
    ],
    "CLFS": [
        "CLIFFS"
    ],
    "CLB": [
        "CLUB"
    ],
    "CMN": [
        "COMMON"
    ],
    "CMNS": [
        "COMMONS"
    ],
    "COR": [
        "CORNER"
    ],
    "CORS": [
        "CORNERS"
    ],
    "CRSE": [
        "COURSE"
    ],
    "CT": [
        "COURT"
    ],
    "CTS": [
        "COURTS"
    ],
    "CV": [
        "COVE"
    ],
    "CVS": [
        "COVES"
    ],
    "CRK": [
        "CREEK"
    ],
    "CRES": [
        "CRESCENT",
        "CRSENT",
        "CRSNT"
    ],
    "CRST": [
        "CREST"
    ],
    "XING": [
        "CROSSING",
        "CRSSNG"
    ],
    "XRD": [
        "CROSSROAD"
    ],
    "XRDS": [
        "CROSSROADS"
    ],
    "CURV": [
        "CURVE"
    ],
    "DL": [
        "DALE"
    ],
    "DM": [
        "DAM"
    ],
    "DV": [
        "DIVIDE",
        "DIV",
        "DVD"
    ],
    "DR": [
        "DRIVE",
        "DRIV",
        "DRV",
        "DR"
    ],
    "DRS": [
        "DRIVES"
    ],
    "EST": [
        "ESTATE"
    ],
    "ESTS": [
        "ESTATES"
    ],
    "EXPY": [
        "EXPRESSWAY",
        "EXP",
        "EXPR",
        "EXPRESS",
        "EXPW"
    ],
    "EXT": [
        "EXTENSION",
        "EXTN",
        "EXTNSN"
    ],
    "EXTS": [
        "EXTENSIONS"
    ],
    "FLS": [
        "FALLS"
    ],
    "FRY": [
        "FERRY",
        "FRRY"
    ],
    "FLD": [
        "FIELD"
    ],
    "FLDS": [
        "FIELDS"
    ],
    "FLT": [
        "FLAT"
    ],
    "FLTS": [
        "FLATS"
    ],
    "FRD": [
        "FORD"
    ],
    "FRDS": [
        "FORDS"
    ],
    "FRST": [
        "FOREST",
        "FORESTS"
    ],
    // "FRG": [
    // 	"FORGE",
    // 	"FORG"
    // ],
    // "FRGS": [
    // 	"FORGES"
    // ],
    "FRK": [
        "FORK"
    ],
    "FRKS": [
        "FORKS"
    ],
    "FT": [
        "FORT",
        "FRT"
    ],
    "FWY": [
        "FREEWAY",
        "FREEWY",
        "FRWAY",
        "FRWY"
    ],
    // "GDN": [
    // 	"GARDEN",
    // 	"GARDN",
    // 	"GRDEN",
    // 	"GRDN"
    // ],
    // "GDNS": [
    // 	"GARDENS",
    // 	"GRDNS"
    // ],
    "GTWY": [
        "GATEWAY",
        "GATEWY",
        "GATWAY",
        "GTWAY"
    ],
    "GLN": [
        "GLEN"
    ],
    "GLNS": [
        "GLENS"
    ],
    "GRN": [
        "GREEN"
    ],
    "GRNS": [
        "GREENS"
    ],
    "GRV": [
        "GROVE",
        "GROV"
    ],
    "GRVS": [
        "GROVES"
    ],
    "HBR": [
        "HARBOR",
        "HARB",
        "HARBR",
        "HRBOR"
    ],
    "HBRS": [
        "HARBORS"
    ],
    "HVN": [
        "HAVEN"
    ],
    "HTS": [
        "HEIGHTS",
        "HT"
    ],
    "HWY": [
        "HIGHWAY",
        "HIGHWY",
        "HIWAY",
        "HIWY",
        "HWAY"
    ],
    "HL": [
        "HILL"
    ],
    "HLS": [
        "HILLS"
    ],
    "HOLW": [
        "HOLLOW",
        "HLLW",
        "HOLLOWS",
        "HOLWS"
    ],
    "INLT": [
        "INLET"
    ],
    "IS": [
        "ISLAND",
        "ISLND"
    ],
    "ISS": [
        "ISLANDS",
        "ISLNDS"
    ],
    "ISLE": [
        "ISLES"
    ],
    "JCT": [
        "JUNCTION",
        "JCTION",
        "JCTN",
        "JUNCTN",
        "JUNCTON"
    ],
    "JCTS": [
        "JUNCTIONS",
        "JCTNS"
    ],
    "KY": [
        "KEY"
    ],
    "KYS": [
        "KEYS"
    ],
    // "KNL": [
    // 	"KNOLL",
    // 	"KNOL"
    // ],
    // "KNLS": [
    // 	"KNOLLS"
    // ],
    // "LK": [
    // 	"LAKE"
    // ],
    // "LKS": [
    // 	"LAKES"
    // ],
    "LAND": [
        "LAND"
    ],
    "LNDG": [
        "LANDING",
        "LNDNG"
    ],
    "LN": [
        "LANE"
    ],
    "LGT": [
        "LIGHT"
    ],
    "LGTS": [
        "LIGHTS"
    ],
    "LF": [
        "LOAF"
    ],
    "LCK": [
        "LOCK"
    ],
    "LCKS": [
        "LOCKS"
    ],
    "LDG": [
        "LODGE",
        "LDGE",
        "LODG"
    ],
    "LOOP": [
        "LOOPS"
    ],
    "MALL": [
        "MALL"
    ],
    "MNR": [
        "MANOR"
    ],
    "MNRS": [
        "MANORS"
    ],
    // "MDW": [
    // 	"MEADOW"
    // ],
    // "MDWS": [
    // 	"MEADOWS",
    // 	"MDW",
    // 	"MEDOWS"
    // ],
    // "MEWS": [
    // 	"MEWS"
    // ],
    "ML": [
        "MILL"
    ],
    "MLS": [
        "MILLS"
    ],
    "MSN": [
        "MISSION",
        "MISSN",
        "MSSN"
    ],
    "MTWY": [
        "MOTORWAY"
    ],
    "MT": [
        "MOUNT",
        "MNT"
    ],
    "MTN": [
        "MOUNTAIN",
        "MNTAIN",
        "MNTN",
        "MOUNTIN",
        "MTIN"
    ],
    "MTNS": [
        "MOUNTAINS",
        "MNTNS"
    ],
    "NCK": [
        "NECK"
    ],
    "ORCH": [
        "ORCHARD",
        "ORCHRD"
    ],
    "OVAL": [
        "OVL"
    ],
    "OPAS": [
        "OVERPASS"
    ],
    "PARK": [
        "PARKS"
    ],
    "PKWY": [
        "PARKWAY",
        "PARKWY",
        "PKWAY",
        "PKY",
        "PARKWAYS",
        "PKWYS"
    ],
    "PASS": [
        "PASS"
    ],
    "PSGE": [
        "PASSAGE"
    ],
    "PATH": [
        "PATHS"
    ],
    "PIKE": [
        "PIKES"
    ],
    "PNE": [
        "PINE"
    ],
    "PNES": [
        "PINES"
    ],
    "PL": [
        "PLACE"
    ],
    "PLN": [
        "PLAIN"
    ],
    "PLNS": [
        "PLAINS"
    ],
    "PLZ": [
        "PLAZA",
        "PLZA"
    ],
    "PT": [
        "POINT"
    ],
    "PTS": [
        "POINTS"
    ],
    "PRT": [
        "PORT"
    ],
    "PRTS": [
        "PORTS"
    ],
    "PR": [
        "PRAIRIE",
        "PRR"
    ],
    "RADL": [
        "RADIAL",
        "RAD",
        "RADIEL"
    ],
    "RAMP": [
        "RAMP"
    ],
    "RNCH": [
        "RANCH",
        "RANCHES",
        "RNCHS"
    ],
    "RPD": [
        "RAPID"
    ],
    "RPDS": [
        "RAPIDS"
    ],
    "RST": [
        "REST"
    ],
    "RDG": [
        "RIDGE",
        "RDGE"
    ],
    "RDGS": [
        "RIDGES"
    ],
    // Not valid for softpak 
    // "RIV": [
    // 	"RIVER",
    // 	"RVR",
    // 	"RIVR"
    // ],
    "RD": [
        "ROAD"
    ],
    "RDS": [
        "ROADS"
    ],
    "RTE": [
        "ROUTE"
    ],
    "ROW": [
        "ROW"
    ],
    "RUE": [
        "RUE"
    ],
    "RUN": [
        "RUN"
    ],
    "SHL": [
        "SHOAL"
    ],
    "SHLS": [
        "SHOALS"
    ],
    "SHR": [
        "SHORE",
        "SHOAR"
    ],
    "SHRS": [
        "SHORES",
        "SHOARS"
    ],
    "SKWY": [
        "SKYWAY"
    ],
    // "SPG": [
    // 	"SPRING",
    // 	"SPNG",
    // 	"SPRNG"
    // ],
    // "SPGS": [
    // 	"SPRINGS",
    // 	"SPNGS",
    // 	"SPRNGS"
    // ],
    "SPUR": [
        "SPURS"
    ],
    "SQ": [
        "SQUARE",
        "SQR",
        "SQRE",
        "SQU"
    ],
    "SQS": [
        "SQUARES",
        "SQRS"
    ],
    "STA": [
        "STATION",
        "STATN",
        "STN"
    ],
    "STRA": [
        "STRAVENUE",
        "STRAV",
        "STRAVEN",
        "STRAVN",
        "STRVN",
        "STRVNUE"
    ],
    "STRM": [
        "STREAM",
        "STREME"
    ],
    "ST": [
        "STREET",
        "STRT",
        "STR"
    ],
    "STS": [
        "STREETS"
    ],
    "SMT": [
        "SUMMIT",
        "SUMIT",
        "SUMITT"
    ],
    "TER": [
        "TERRACE",
        "TERR"
    ],
    "TRWY": [
        "THROUGHWAY"
    ],
    "TRCE": [
        "TRACE",
        "TRACES"
    ],
    "TRAK": [
        "TRACK",
        "TRACKS",
        "TRK",
        "TRKS"
    ],
    "TRFY": [
        "TRAFFICWAY"
    ],
    "TRL": [
        "TRAIL",
        "TRAILS",
        "TRLS"
    ],
    "TRLR": [
        "TRAILER",
        "TRLRS"
    ],
    "TUNL": [
        "TUNNEL",
        "TUNEL",
        "TUNLS",
        "TUNNELS",
        "TUNNL"
    ],
    "TPKE": [
        "TURNPIKE",
        "TRNPK",
        "TURNPK"
    ],
    "UPAS": [
        "UNDERPASS"
    ],
    "UN": [
        "UNION"
    ],
    "UNS": [
        "UNIONS"
    ],
    "VLY": [
        "VALLEY",
        "VALLY",
        "VLLY"
    ],
    "VLYS": [
        "VALLEYS",
        "VLYS"
    ],
    "VIA": [
        "VIADUCT",
        "VDCT",
        "VIADCT",
        "VIA",
    ],
    "VIEW": [
        "VIEW",
        "VW"
    ],
    "VWS": [
        "VIEWS",
        "VWS"
    ],
    // softpak don't support
    // "VLG": [
    // 	"VILLAGE",
    // 	"VILL",
    // 	"VILLAG",
    // 	"VILLG",
    // 	"VILLIAGE"
    // ],
    // "VLGS": [
    // 	"VILLAGES"
    // ],
    "VL": [
        "VILLE"
    ],
    "VIS": [
        "VISTA",
        "VIST",
        "VST",
        "VSTA"
    ],
    "WALK": [
        "WALKS"
    ],
    "WALL": [
        "WALL"
    ],
    "WAY": [
        "WY"
    ],
    "WAYS": [
        "WAYS"
    ],
    "WL": [
        "WELL"
    ],
    "WLS": [
        "WELLS"
    ]
};
exports.SubpremiseLevelList = [
    'APT',
    'APARTMENT',
    'UNIT',
    'BLDG',
    'BUILDING',
    'DEPT',
    'DEPARTMENT',
    'SUITE',
    'STE',
    'FLOOR',
    'FL',
];
var AddressValidatorService;
(function (AddressValidatorService) {
    AddressValidatorService["GOOGLE"] = "googleApi";
})(AddressValidatorService || (exports.AddressValidatorService = AddressValidatorService = {}));
// add more as needed
exports.addressLevelConversion = {
    'FIRST': '1',
    '1ST': '1',
    'SECOND': '2',
    '2ND': '2',
    'THIRD': '3',
    '3RD': '3',
    'FOURTH': '4',
    '4TH': '4',
    'FIFTH': '5',
    '5TH': '5',
};
// Should only be intergrated/use in geocoderApi at moment.
class AddressUtil {
}
exports.AddressUtil = AddressUtil;
_a = AddressUtil;
// only the street should be pass in and not the full address
// Incorrect ex: 540 E 9th St #2b, Brooklyn, NY 11218, USA
// Correct ex: 540 E 9th St #2b
AddressUtil.getStreetName = ({ street, isStreetName }) => {
    var _b, _c, _d, _e, _f, _g, _h, _j;
    let parsedStreet = street.toLocaleUpperCase();
    if (!parsedStreet) {
        return null;
    }
    if (isStreetName !== true) {
        parsedStreet = (_c = (_b = _a.getStreetNumber({ street: parsedStreet, removeNumberFromStreet: true })) === null || _b === void 0 ? void 0 : _b.street) !== null && _c !== void 0 ? _c : parsedStreet;
    }
    parsedStreet = (_e = (_d = _a.getSubpremiseLevel({ street: parsedStreet, removeAptFromStreet: true })) === null || _d === void 0 ? void 0 : _d.street) !== null && _e !== void 0 ? _e : parsedStreet;
    parsedStreet = (_g = (_f = _a.getDirection({ street: parsedStreet, removeDirectionFromStreet: true })) === null || _f === void 0 ? void 0 : _f.street) !== null && _g !== void 0 ? _g : parsedStreet;
    let splitValue = parsedStreet.split(' ');
    if ((splitValue.length > 1 && !(0, validation_1.hasNumber)(splitValue[0])) || splitValue.length > 2) {
        parsedStreet = (_j = (_h = _a.getStreetSuffix({ street: parsedStreet, removeSuffixFromStreet: true, parseSuffixOnly: true })) === null || _h === void 0 ? void 0 : _h.street) !== null && _j !== void 0 ? _j : parsedStreet;
    }
    return parsedStreet;
};
// Street could potentially be the full formated address.
// ex: 724 west main st, First floor, Lansdale, PA 19446, USA'
// ex: 724 west main st'
AddressUtil.getSubpremiseLevel = ({ street, removeAptFromStreet }) => {
    var _b;
    // Address subpremiseLevel should follow by street:
    // ex: 724 west main st floor 1, Lansdale, PA 19446, USA
    // But due to customer input the following address entry could occur
    // ex: '724 west main st, First floor, Lansdale, PA 19446, USA' => "floor Lansdale" when it should be "first floor" due to algorithm logic
    // Therefore we can't replace all commas as empty space since it could affect the value of the subpremiseLevel
    let parsedStreet = street.toLocaleUpperCase();
    let streetNameList = parsedStreet.split(' ');
    let subpremiseLevel = undefined;
    let removeIndex = [];
    for (let i = 0; i < streetNameList.length - 1; i++) {
        let commasFlag = false; // indecate that the level is before the subpremise unit. ex: 1st floor,
        let currentStreetNameElement = streetNameList[i];
        if (currentStreetNameElement.includes(',')) {
            commasFlag = true;
            currentStreetNameElement = currentStreetNameElement.replaceAll(',', '');
        }
        if (exports.SubpremiseLevelList.includes(currentStreetNameElement)) {
            if (streetNameList[i + 1] !== undefined) {
                let level = '';
                if (commasFlag) {
                    level = streetNameList[i - 1];
                }
                else {
                    level = streetNameList[i + 1];
                }
                level = level.replaceAll(',', ''); // clean up any commas that is attact to the level string
                level = (_b = exports.addressLevelConversion[level]) !== null && _b !== void 0 ? _b : level;
                if (!(0, validation_1.hasNumber)(level)) {
                    continue; // the leve is not a number continue loop
                }
                // floor is included in the sub
                if (currentStreetNameElement === 'FLOOR' || currentStreetNameElement === 'FL') {
                    subpremiseLevel = currentStreetNameElement + ' ' + level;
                }
                else {
                    subpremiseLevel = level;
                }
            }
        }
        if (subpremiseLevel && removeAptFromStreet === true) {
            removeIndex.push(i);
            if (commasFlag) {
                removeIndex.push(i - 1);
            }
            else {
                removeIndex.push(i + 1);
            }
            break;
        }
    }
    // checking last case
    if (!subpremiseLevel) {
        // no SubpremiseLevelList found but contain a #
        if (validation_1.Regex.addressUnit.test(streetNameList[streetNameList.length - 1])) {
            subpremiseLevel = streetNameList[streetNameList.length - 1];
            removeIndex.push(streetNameList.length - 1);
        }
    }
    if (removeIndex.length !== 0) {
        removeIndex.map((index) => {
            streetNameList[index] = undefined;
        });
    }
    if (subpremiseLevel) {
        return { value: subpremiseLevel, street: streetNameList.filter(Boolean).join(' ') };
    }
    return undefined;
};
AddressUtil.getStreetNumber = ({ street, removeNumberFromStreet }) => {
    let parsedStreet = street.replace(',', '').toLocaleUpperCase();
    let streetNameList = parsedStreet.split(' ');
    // let streetNumber = undefined;
    let removeIndex = [];
    // for (let i = 0; i < streetNameList.length - 1; i++) {
    // 	if (hasNumber(streetNameList[i]) && !streetNameList[i].includes('TH') && !streetNameList[i].includes('RD') && !streetNameList[i].includes('ND')) {
    // 		streetNumber = streetNameList[i];
    // 		if (removeNumberFromStreet === true) {
    // 			removeIndex.push(i);
    // 		}
    // 		break;
    // 	}
    // }
    // if (removeIndex.length !== 0) {
    // 	removeIndex.map((index: number) => {
    // 		streetNameList[index] = undefined;
    // 	});
    // }
    // TODO: get a more in depth look into it later... street number should only be a number and should not even have to check for 'TH', 'RD' or 'ND'
    let streetNumber = streetNameList[0];
    if ((0, validation_1.hasNumber)(streetNumber) && !streetNumber.includes('TH') && !streetNumber.includes('RD') && !streetNumber.includes('ND')) {
        streetNameList[0] = undefined;
    }
    if (streetNumber) {
        return { value: streetNumber, street: streetNameList.filter(Boolean).join(' ') };
    }
    return undefined;
};
AddressUtil.getDirection = ({ street, removeDirectionFromStreet, }) => {
    let parsedStreet = street.replace(',', '').replace('.', '').toLocaleUpperCase();
    let streetNameList = parsedStreet.split(' ');
    let direction = [];
    let removeIndex = [];
    for (let i = 0; i < streetNameList.length; i++) {
        let currentDirection = null;
        for (const [key, values] of Object.entries(exports.streetDirection)) {
            if (values.includes(streetNameList[i]) || streetNameList[i] === key) {
                // for case where the street is a direction + "ST"
                if (streetNameList[i + 1] !== undefined && (streetNameList[i + 1] === 'ST' || streetNameList[i + 1] === 'STREET')) {
                    continue;
                }
                currentDirection = key;
                break;
            }
        }
        if (currentDirection !== null) {
            direction.push(currentDirection);
            if (removeDirectionFromStreet === true) {
                removeIndex.push(i);
            }
        }
    }
    if (removeIndex.length !== 0) {
        removeIndex.map((index) => {
            streetNameList[index] = undefined;
        });
    }
    if (direction.length > 0) {
        return { value: direction, street: streetNameList.filter(Boolean).join(' ') };
    }
    return undefined;
};
AddressUtil.getStreetSuffix = ({ street, removeSuffixFromStreet, parseSuffixOnly }) => {
    var _b, _c, _d, _e, _f, _g;
    let parsedStreet = street.toLocaleUpperCase().replaceAll(',', '').replaceAll('.', '');
    // check if the address is already clean up removing other component of the address so the code can tell if the 'Street' is a suffix or not
    // if address is already clean up/parsed then skip.
    if (parseSuffixOnly !== true) {
        parsedStreet = (_c = (_b = _a.getStreetNumber({ street: parsedStreet, removeNumberFromStreet: true })) === null || _b === void 0 ? void 0 : _b.street) !== null && _c !== void 0 ? _c : parsedStreet;
        parsedStreet = (_e = (_d = _a.getSubpremiseLevel({ street: parsedStreet, removeAptFromStreet: true })) === null || _d === void 0 ? void 0 : _d.street) !== null && _e !== void 0 ? _e : parsedStreet;
        parsedStreet = (_g = (_f = _a.getDirection({ street: parsedStreet, removeDirectionFromStreet: true })) === null || _f === void 0 ? void 0 : _f.street) !== null && _g !== void 0 ? _g : parsedStreet;
    }
    let suffix = '';
    let removeIndex = [];
    let streetNameList = parsedStreet.split(' ');
    // not suffix only the street name is left
    if (streetNameList.length <= 1) {
        return undefined;
    }
    // first part of the street name is a number so there should be no suffix
    // ex: 9th street = "streetName"; street is not a sufix in this case.
    if (streetNameList.length === 2 && (0, validation_1.hasNumber)(streetNameList[0])) {
        return undefined;
    }
    for (let i = streetNameList.length - 1; i >= 0; i--) {
        if (i === 0) {
            break; // suffix should not be before streetName
        }
        let currentSuffix = null;
        for (const [key, values] of Object.entries(exports.streetSuffix)) {
            if (values.includes(streetNameList[i]) || streetNameList[i] === key && i !== 0) {
                currentSuffix = key;
                break;
            }
        }
        if (currentSuffix !== null) {
            suffix += currentSuffix;
            if (removeSuffixFromStreet === true) {
                removeIndex.push(i);
            }
            // only taking one suffix starting from right to left
            break;
        }
    }
    if (removeIndex.length !== 0) {
        removeIndex.map((index) => {
            streetNameList[index] = undefined;
        });
    }
    if (suffix.length > 0) {
        let returnValue = { value: suffix, street: streetNameList.filter(Boolean).join(' ') };
        return returnValue;
    }
    return undefined;
};
AddressUtil.getHighestConfidenceAddress = (list) => {
    if (list.length !== 0) {
        let result = list[0];
        if (list.length > 1) {
            let highestConfidenceLevel = 0;
            list.map((address) => {
                var _b, _c;
                if (((_b = address.getConfidence()) !== null && _b !== void 0 ? _b : 0) > highestConfidenceLevel) {
                    highestConfidenceLevel = (_c = address.getConfidence()) !== null && _c !== void 0 ? _c : 0;
                    result = address;
                }
            });
        }
        return result;
    }
    return null;
};
AddressUtil.validateReverseGeocodeAddressProximity = ({ address1, address2 }) => {
    var _b, _c, _d, _e;
    if (address1.getZipcode() !== address2.getZipcode()
        && address1.getCity() !== address2.getCity()
        && address1.getAdministrativeLevel1() !== address2.getAdministrativeLevel1()
        && address1.getAdministrativeLevel2() !== address2.getAdministrativeLevel2()
        && Math.abs(((_b = address1.getLat()) !== null && _b !== void 0 ? _b : 0) - ((_c = address2.getLat()) !== null && _c !== void 0 ? _c : 0)) < 0.001
        && Math.abs(((_d = address1.getLng()) !== null && _d !== void 0 ? _d : 0) - ((_e = address2.getLng()) !== null && _e !== void 0 ? _e : 0)) < 0.001) {
        return true;
    }
    return false;
};
//# sourceMappingURL=AddressUtil.js.map