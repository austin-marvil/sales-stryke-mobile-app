"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringUtils = void 0;
class StringUtils {
    static firstCharToLowerCase(value) {
        let result = value.substring(0, 1).toLocaleLowerCase() + value.substring(1);
        return (result);
    }
    static firstCharToUpperCase(value) {
        let result = value.substring(0, 1).toLocaleUpperCase() + value.substring(1);
        return (result);
    }
    static capitalizeFirstLetter(value) {
        if (!value || typeof value !== 'string') {
            return '';
        }
        let result = value.substring(0, 1).toLocaleUpperCase() + value.substring(1).toLocaleLowerCase();
        return result;
    }
    static capitalizeWordsFirstLetter(value) {
        if (!value || typeof value !== 'string') {
            return '';
        }
        // Replace _ or - with space
        let formatted = value.replace(/[_-]/g, ' ');
        // Capitalize first letter of each word, lowercase the rest
        formatted = formatted.replace(/\b(\w)(\w*)\b/g, (_, first, rest) => first.toUpperCase() + rest.toLowerCase());
        return formatted;
    }
    static getAsQuotedString(value_s) {
        if (value_s === null) {
            return ("\"\"");
        }
        let quoted_s = "\"";
        let value_ary_m = value_s.split('');
        let index_i_m = 0;
        for (index_i_m = 0; index_i_m < value_ary_m.length; index_i_m++) {
            let char_s_m = value_ary_m[index_i_m];
            if (char_s_m === "\\") {
                quoted_s += "\\" + char_s_m;
            }
            else {
                quoted_s += char_s_m;
            }
        }
        quoted_s += "\"";
        return (quoted_s);
    }
    static camelCaseToAllUpperCaseSeparatedByUnderscore(p) {
        let newValue_s = '';
        // let previousIndex
        // const upperCaseIndexes_ary = [];
        // for (let index_i = 0; index_i < p.value.length; index_i++) {
        //     if (/[A-Z]/.test(p.value[index_i])) {
        //         upperCaseIndexes_ary.push(index_i);
        //     }
        // }
        // let index_i     : number = 0;
        // let size_i      : number = upperCaseIndexes_ary.length;
        // for(index_i = 0; index_i < size_i; index_i++)
        // {
        //     let upperCaseIndex_i : number = upperCaseIndexes_ary[index_i];
        // }
        newValue_s = p.value.replace(/[A-Z]/g, match => '_' + match.toLowerCase());
        if (newValue_s[0] === '_') {
            newValue_s = newValue_s.substring(1);
        }
        return (newValue_s);
    }
    static escapeRegExp(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
    }
    static replaceAll(str, find, replace) {
        return str.replace(new RegExp(StringUtils.escapeRegExp(find), 'g'), replace);
    }
    static spacePascalCase(value_s) {
        return value_s
            .replace(/([A-Z])/g, ' $1')
            .trim();
    }
    static snakeCase(value_s) {
        return value_s.toLowerCase().replace(/\s+/g, '_');
    }
    static nullStringIsEmptyString(value) {
        return value !== null && value !== void 0 ? value : "";
    }
    /**
     * Cleans a string so it is safe for use as a value in a JSON object.
     * Removes control characters, trims whitespace, and replaces problematic unicode.
     * Ensures the string can be safely stringified and parsed as JSON.
     */
    /* eslint-disable no-control-regex */
    static cleanForJson(value) {
        if (value == null)
            return '';
        try {
            // Remove control characters except for common whitespace (tab, newline, carriage return)
            let cleaned = value.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, '');
            // Remove unpaired surrogates (invalid unicode)
            cleaned = cleaned.replace(/([\uD800-\uDBFF])(?![\uDC00-\uDFFF])|(?<![\uD800-\uDBFF])([\uDC00-\uDFFF])/g, '');
            // Trim leading/trailing whitespace
            cleaned = cleaned.trim();
            // Optionally, replace problematic quotes
            // cleaned = cleaned.replace(/"/g, '\\"'); // is already handled by JSONObject entity method .toString() 
            return cleaned;
        }
        catch (error) {
            console.error('Error in cleanForJson:', error);
            return ''; // Return empty string on error
        }
    }
}
exports.StringUtils = StringUtils;
//# sourceMappingURL=StringUtils.js.map