"use strict";
var _a, _HttpClient_callMethodName;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const HttpMethodType_1 = require("../../http/HttpMethodType");
const TypeScriptToJsonApi_1 = require("../../jsonApi/transform/TypeScriptToJsonApi");
const LogManager_1 = require("../../utils/log/LogManager");
const JsonApiToTypeScript_1 = require("../../jsonApi/transform/JsonApiToTypeScript");
const AttributeValidationError_1 = require("../../data/entity/errors/AttributeValidationError");
const JsonApiErrorMetaErrorType_1 = require("../../jsonApi/JsonApiErrorMetaErrorType");
const ErrorBase_1 = require("../../lang/ErrorBase");
const AuthorizationError_1 = require("../../security/AuthorizationError");
const LogLevel_1 = require("../log/LogLevel");
const NAMESPACE = "com.salesstryke.utils.httpclient.HttpClient";
const LOGGER = LogManager_1.LogManager.getLogger(NAMESPACE);
LOGGER.setLogLevel(LogLevel_1.Level.WARNING);
class HttpClient {
    /**
     *
     * @param scheme
     * @param domain
     * @param port
     */
    constructor(scheme, domain, port) {
        this.config = {};
        /**
         * A config item.
         */
        this.isAuthenticated_b = false;
        this.jwtToken = "";
        this.scheme = scheme;
        this.domain = domain;
        this.port = port;
        this.baseURI = `${this.scheme}://${this.domain}:${this.port}`;
        // TODO: fix the following
        // shouldn't be logging in warning...
        LOGGER.logInfo({ message: `scheme: ${scheme} ` });
        LOGGER.logInfo({ message: `domain: ${domain} ` });
        LOGGER.logInfo({ message: `port: ${port} ` });
        LOGGER.logInfo({ message: `baseURI: ${this.baseURI} ` });
    }
    call(httpMethodType, path_s, jsonApiDocument) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fullPath_s = this.baseURI + path_s;
            let typeScriptToJsonApi = new TypeScriptToJsonApi_1.TypeScriptToJsonApi();
            let json_s = typeScriptToJsonApi.execute(jsonApiDocument);
            // eslint-disable-next-line
            let _this = this;
            let json_obj = null;
            let jsonApiDocument_s = '';
            try {
                if (LOGGER.isInfoEnabled()) {
                    let jsonPretty_s = JSON.stringify(json_obj, null, 2);
                    LOGGER.logInfo({ message: `REQUEST path: ${fullPath_s} json: ${jsonPretty_s}`, methodName: this.call.name });
                    jsonApiDocument_s = JSON.stringify(typeScriptToJsonApi);
                    LOGGER.logInfo({ message: `JsonApiDocument as json : ${json_s}`, methodName: this.call.name });
                    jsonApiDocument_s = JSON.stringify(typeScriptToJsonApi, null, 2);
                    LOGGER.logInfo({ message: `JsonApiDocument Pretty: ${jsonApiDocument_s}`, methodName: this.call.name });
                }
                json_obj = JSON.parse(json_s);
            }
            catch (error_any) {
                let error = error_any;
                LOGGER.logError({ message: `json_s : ${json_s}, error message : ${error.message} stack : ${error.stack}`, methodName: this.call.name });
            }
            if (LOGGER.isInfoEnabled()
            // && (fullPath_s.includes('/import_data_map/save'))
            ) {
                try {
                    let jsonPretty_s = JSON.stringify(json_obj, null, 2);
                    LOGGER.logInfo({ message: `REQUEST path: ${fullPath_s} json: ${jsonPretty_s}`, methodName: this.call.name });
                }
                catch (error_any) {
                    let error = error_any;
                    LOGGER.logError({ message: `${error.message} ${error.stack}`, methodName: this.call.name });
                }
                //LOGGER.logInfo({ message : `REQUEST path: ${fullPath_s} json(100 chars): ${jsonPretty_s.substring(0, 100)}`, methodName : this.call.name });
            }
            if (json_s.includes('packages.common.com.salesstryke.entity.classes.persistable.WorkspaceTemplate')) {
                let noop = '';
            }
            return new Promise((resolve, reject) => {
                let noop = "";
                // eslint-disable-next-line
                let self = this;
                switch (httpMethodType) {
                    case HttpMethodType_1.HttpMethodType.GET:
                        // let cloneConfig: Object = JSON.parse(JSON.stringify(this.config));
                        // let merged: Object = Object.assign(cloneConfig, json_obj);
                        axios_1.default.get(fullPath_s, this.config).then(function (response) {
                            let data = response.data;
                            if (LOGGER.isInfoEnabled()) {
                                let data_s = JSON.stringify(data, null, 2);
                                LOGGER.logInfo({ message: `GET RESPONSE: ${data_s}`, methodName: _this.call.name });
                            }
                            let jsonApiToTypeScript = new JsonApiToTypeScript_1.JsonApiToTypeScript().setClearAllMutatdFlages(true);
                            let jad = jsonApiToTypeScript.execute(data);
                            resolve(jad);
                        })
                            .catch(function (error_any) {
                            let error = error_any;
                            let errorBase = new ErrorBase_1.ErrorBase(`GET error: ${error.message} for path: ${path_s}`, NAMESPACE, tslib_1.__classPrivateFieldGet(_a, _a, "f", _HttpClient_callMethodName), "fa4a216b-b96c-45ef-954b-9a989557e7b9", error);
                            if (LOGGER.isErrorEnabled()) {
                                LOGGER.logErrorBase(errorBase);
                            }
                            reject(error);
                        });
                        // .then(function(result_any: any) {
                        //     noop = "";
                        // });
                        break;
                    case HttpMethodType_1.HttpMethodType.POST:
                        axios_1.default.post(fullPath_s, json_obj, this.config).then(function (response) {
                            let data = response.data;
                            // For debugging
                            if (fullPath_s === 'http://localhost:8080/kml/getall') {
                                let data_s = JSON.stringify(data, null, 2);
                                LOGGER.logInfo({ message: `POST RESPONSE: ${data_s}`, methodName: _this.call.name });
                            }
                            let jsonApiToTypeScript = new JsonApiToTypeScript_1.JsonApiToTypeScript().setClearAllMutatdFlages(true);
                            let jad = jsonApiToTypeScript.execute(data);
                            // Use For Debugging
                            // if(jad.getData().length > 0) 
                            // {
                            //     let temp_any: any = jad.getData()[0];
                            //     let temp_japb: JsonApiPersistableBase = (temp_any as JsonApiPersistableBase);
                            //     if(temp_japb.getClassName() === 'packages.common.com.salesstryke.entity.classes.persistable.WorkspaceTemplate')
                            //     {
                            //         let noop: string = '';
                            //     }
                            // }
                            let errors_jae = jad.getErrors();
                            //jad.getData();
                            if (errors_jae.length > 0) {
                                let errorBase_ary = self.getJsonApiErrorsAsErrors(errors_jae);
                                let errorBase = errorBase_ary[0];
                                reject(errorBase);
                            }
                            else {
                                resolve(jad);
                            }
                        })
                            .catch(function (error) {
                            if (axios_1.default.isAxiosError(error)) {
                                if (error.status === 500 && LOGGER.isErrorEnabled()) {
                                    const errorBase = new ErrorBase_1.ErrorBase(`POST error: ${error.message} for path: ${path_s}. Has HttpMethod been added to ServerMain?`, NAMESPACE, tslib_1.__classPrivateFieldGet(_a, _a, "f", _HttpClient_callMethodName), 'b3daa41f-66b2-4ff8-9923-486b9f99b9f5', error);
                                    LOGGER.logErrorBase(errorBase);
                                }
                            }
                            reject(error);
                        });
                        break;
                    case HttpMethodType_1.HttpMethodType.PUT:
                        axios_1.default.post(fullPath_s, json_obj, this.config).then(function (response) {
                            let data = response.data;
                            let jsonApiToTypeScript = new JsonApiToTypeScript_1.JsonApiToTypeScript();
                            let jad = jsonApiToTypeScript.execute(data);
                            let errors_jae = jad.getErrors();
                            if (errors_jae.length > 0) {
                                let errorBase_ary = self.getJsonApiErrorsAsErrors(errors_jae);
                                reject(errorBase_ary);
                            }
                            else {
                                resolve(jad);
                            }
                        })
                            .catch(function (error_any) {
                            let error = error_any;
                            let errorBase = new ErrorBase_1.ErrorBase(`POST error: ${error.message} for path: ${path_s}. Has HttpMethod been added to ServerMain?`, NAMESPACE, tslib_1.__classPrivateFieldGet(_a, _a, "f", _HttpClient_callMethodName), "fe09a9b2-aeac-4c7e-8d73-ead4d5b117c1", error);
                            if (LOGGER.isErrorEnabled()) {
                                LOGGER.logErrorBase(errorBase);
                            }
                            reject(error);
                        });
                        break;
                    default:
                        noop = "";
                        break;
                }
            });
        });
    }
    getIsAuthenticated() {
        return (this.isAuthenticated_b);
    }
    getJsonApiErrorsAsErrors(errors_jae) {
        let errorBase_ary = new Array();
        let noop = "";
        //errors_jae.forEach((jsonApiError: JsonApiError) => {
        let size_i = errors_jae.length;
        for (let index_i = 0; index_i < size_i; index_i++) {
            let jsonApiError = errors_jae[index_i];
            let code_s = jsonApiError.getCode() || "";
            let detail_s = jsonApiError.getDetail() || "";
            let errorType_s = null;
            let id_s = jsonApiError.getId() || "";
            let status_s = jsonApiError.getStatus() || "";
            let title_s = jsonApiError.getTitle() || "";
            let i18nKey_s = '';
            let source_s = '';
            let endPoint_s = '';
            let message_s = '';
            let methodName_s = '';
            let namespace_s = "";
            let userUUID_s = '';
            let securityAttributeUUID_s = '';
            let uiUUID_s = '';
            let meta = jsonApiError.getMeta();
            if (meta !== null) {
                i18nKey_s = meta.getI18nKey() || '';
                endPoint_s = meta.getEndPoint() || '';
                message_s = meta.getFullMessage();
                methodName_s = meta.getMethodName() || "";
                namespace_s = meta.getNamespace() || "";
                userUUID_s = meta.getUserUUID();
                securityAttributeUUID_s = meta.getSecurityAttributeUUID();
                uiUUID_s = meta.getUIUUID();
            }
            if (errorType_s === JsonApiErrorMetaErrorType_1.JsonApiErrorMetaErrorType.ATTRIBUTE_INVALID.toString()) {
                let validationError = new AttributeValidationError_1.AttributeValidationError(message_s, userUUID_s, securityAttributeUUID_s, namespace_s, methodName_s, i18nKey_s, uiUUID_s);
                errorBase_ary.push(validationError);
            }
            else if (errorType_s === JsonApiErrorMetaErrorType_1.JsonApiErrorMetaErrorType.AUTHORIZATION.toString()) {
                let authorizationError = new AuthorizationError_1.AuthorizationError(detail_s, userUUID_s, securityAttributeUUID_s, namespace_s, methodName_s);
                errorBase_ary.push(authorizationError);
            }
            else {
                let baseErrorMessage_s = `message: '${message_s} detail: ${detail_s} endPoint: '${endPoint_s}'`;
                let errorBase = new ErrorBase_1.ErrorBase(baseErrorMessage_s, NAMESPACE, tslib_1.__classPrivateFieldGet(_a, _a, "f", _HttpClient_callMethodName), "8111d7d6-c497-4903-9896-488c98f599fe", null);
                errorBase_ary.push(errorBase);
                if (LOGGER.isErrorEnabled()) {
                    LOGGER.logErrorBase(errorBase);
                }
            }
        }
        return (errorBase_ary);
    }
    getJwtToken() {
        return (this.jwtToken);
    }
    logout() {
        this.config = {};
        this.isAuthenticated_b = false;
        this.jwtToken = "";
    }
    setIsAuthenticated(isAuthenticated_b) {
        this.isAuthenticated_b = isAuthenticated_b;
        return (this);
    }
    setJwtToken(jwtToken) {
        this.jwtToken = jwtToken;
        this.updateConfig();
        return (this);
    }
    updateConfig() {
        this.config = {
            headers: {
                "Authorization": `Bearer ${this.jwtToken}`
            }
        };
    }
}
exports.HttpClient = HttpClient;
_a = HttpClient;
_HttpClient_callMethodName = { value: "call" };
//# sourceMappingURL=HttpClient.js.map