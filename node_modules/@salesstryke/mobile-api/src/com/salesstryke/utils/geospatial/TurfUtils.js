"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TurfUtils = void 0;
const helpers_1 = require("@turf/helpers");
const boolean_within_1 = require("@turf/boolean-within");
const boolean_intersects_1 = require("@turf/boolean-intersects");
const boolean_point_in_polygon_1 = require("@turf/boolean-point-in-polygon");
const union_1 = require("@turf/union");
const difference_1 = require("@turf/difference");
const buffer_1 = require("@turf/buffer");
const intersect_1 = require("@turf/intersect");
const centroid_1 = require("@turf/centroid");
const point_on_feature_1 = require("@turf/point-on-feature");
const center_of_mass_1 = require("@turf/center-of-mass");
/**
 * Utility functions for working with Turf.js
 */
class TurfUtils {
    /**
     * Calculate the Euclidean distance between two points
     */
    static calculateDistance(point1, point2) {
        const dx = point2[0] - point1[0];
        const dy = point2[1] - point1[1];
        return Math.sqrt(dx * dx + dy * dy);
    }
}
exports.TurfUtils = TurfUtils;
_a = TurfUtils;
/**
 * Convert lat/lng coordinates to a Turf.js polygon
 */
TurfUtils.toTurfPolygon = (rings) => {
    const coords = rings.map((ring) => ring.map((p) => [p.lng, p.lat]));
    // Ensure each ring is closed
    coords.forEach((ring) => {
        if (ring[0][0] !== ring[ring.length - 1][0] ||
            ring[0][1] !== ring[ring.length - 1][1]) {
            ring.push(ring[0]);
        }
    });
    return (0, helpers_1.polygon)(coords); // Creates a Turf.js Polygon with holes
};
/**
 * Convert a GeoJSON polygon to lat/lng coordinates
 */
TurfUtils.toLatLngLiteral = (geo) => {
    if (geo.type === 'Polygon') {
        return geo.coordinates.map((ring) => ring.map(([lng, lat]) => ({ lat, lng })));
    }
    if (geo.type === 'MultiPolygon') {
        return geo.coordinates.flatMap((poly) => poly.map((ring) => ring.map(([lng, lat]) => ({ lat, lng }))));
    }
    return [];
};
/**
 * Update a polygon with a hole
 */
TurfUtils.updatePolygonWithHole = (original, newHole) => {
    const [outerRing, ...holes] = original.geometry.coordinates;
    // Convert rings to features for holes
    const holeFeatures = holes.map((coords) => (0, helpers_1.polygon)([coords]));
    // Find holes intersecting newHole
    const intersectingHoles = holeFeatures.filter((hole) => (0, boolean_intersects_1.default)(hole, newHole));
    const newHoleFullyInsideOuter = (0, boolean_within_1.default)(newHole, original);
    const newHoleIntersectsOuter = (0, boolean_intersects_1.default)(newHole, original);
    if (newHoleFullyInsideOuter && intersectingHoles.length === 0) {
        // Case 1: fully inside outer, no hole intersections -> add as new hole
        // Validate newHole coordinates
        const newHoleCoords = newHole.geometry.coordinates[0];
        if (!newHoleCoords || newHoleCoords.length < 3) {
            console.error('Invalid newHole coordinates.');
            return null;
        }
        // Check for duplicate holes
        const isDuplicateHole = holes.some((hole) => JSON.stringify(hole) === JSON.stringify(newHoleCoords));
        if (isDuplicateHole) {
            console.warn('Duplicate hole detected. Skipping addition.');
            return (0, helpers_1.polygon)([outerRing, ...holes]);
        }
        // Add the new hole to the list of holes
        const newCoords = [outerRing, ...holes, newHoleCoords];
        const result = (0, helpers_1.polygon)(newCoords);
        // Validate the result
        if (result.geometry.type !== 'Polygon') {
            console.error('Result is not a valid Polygon.');
            return null;
        }
        return result;
    }
    else if (newHoleIntersectsOuter && intersectingHoles.length === 0) {
        // Case 4: intersects outer boundary (partially outside) â€” subtract newHole from outer polygon
        // Start by subtracting newHole from outer polygon
        const updatedOuter = (0, difference_1.default)((0, helpers_1.featureCollection)([original, newHole]));
        if (!updatedOuter ||
            updatedOuter.geometry.type === 'MultiPolygon') {
            console.error('Updated outer resulted in a MultiPolygon, which is not supported.', updatedOuter);
            return null; // Handle MultiPolygon case explicitly
        }
        // Combine the updated outer ring with the original holes
        const updatedOuterCoords = updatedOuter.geometry.coordinates;
        const combinedCoords = [updatedOuterCoords[0], ...holes];
        const result = (0, helpers_1.polygon)(combinedCoords);
        // Validate the result
        if (result.geometry.type !== 'Polygon') {
            console.error('Result is not a valid Polygon.');
            return null;
        }
        return result;
    }
    else if (intersectingHoles.length > 0 && newHoleFullyInsideOuter) {
        // Case 3: newHole intersects one or more holes, but is fully inside outer polygon -> merge newHole with those holes
        // Union all intersecting holes + newHole
        let mergedHole = newHole;
        intersectingHoles.forEach((hole) => {
            mergedHole = (0, union_1.default)((0, helpers_1.featureCollection)([mergedHole, hole]));
        });
        // Ensure mergedHole is a Polygon
        if (mergedHole.geometry.type !== 'Polygon') {
            console.error('Merged hole resulted in a MultiPolygon, which is not supported.');
            return null; // Handle MultiPolygon case explicitly
        }
        // Build new holes list without intersecting holes
        const remainingHoles = holeFeatures.filter((hole) => !intersectingHoles.includes(hole));
        // Rebuild polygon holes with merged hole and remaining holes
        const newHoleCoordsArray = [];
        // Add remaining holes coords
        remainingHoles.forEach((hole) => {
            if (hole.geometry.type === 'Polygon') {
                newHoleCoordsArray.push(hole.geometry.coordinates[0]);
            }
        });
        // Add merged hole coords
        newHoleCoordsArray.push(mergedHole.geometry.coordinates[0]);
        const result = (0, helpers_1.polygon)([outerRing, ...newHoleCoordsArray]);
        // Validate the result
        if (result.geometry.type !== 'Polygon') {
            console.error('Result is not a valid Polygon.');
            return null;
        }
        return result;
    }
    else if (newHoleIntersectsOuter && intersectingHoles.length > 0) {
        // Merge all intersecting holes with the new hole
        let mergedHole = newHole;
        intersectingHoles.forEach((hole) => {
            mergedHole = (0, union_1.default)((0, helpers_1.featureCollection)([mergedHole, hole]));
        });
        // Ensure mergedHole is a Polygon
        if (mergedHole.geometry.type !== 'Polygon') {
            console.error('Merged hole resulted in a MultiPolygon, which is not supported.');
            return null; // Handle MultiPolygon case explicitly
        }
        // Subtract the merged hole from the outer polygon
        const updatedOuter = (0, difference_1.default)((0, helpers_1.featureCollection)([original, mergedHole]));
        if (!updatedOuter ||
            updatedOuter.geometry.type === 'MultiPolygon') {
            console.error('Updated outer resulted in a MultiPolygon, which is not supported.');
            return null; // Handle MultiPolygon case explicitly
        }
        // Combine the updated outer ring with the remaining holes and the merged hole
        const updatedOuterCoords = updatedOuter.geometry.coordinates;
        const remainingHoles = holeFeatures.filter((hole) => !intersectingHoles.includes(hole));
        const newHoleCoordsArray = [];
        // Add remaining holes coords
        remainingHoles.forEach((hole) => {
            if (hole.geometry.type === 'Polygon') {
                newHoleCoordsArray.push(hole.geometry.coordinates[0]);
            }
        });
        const result = (0, helpers_1.polygon)([
            updatedOuterCoords[0],
            ...newHoleCoordsArray,
        ]);
        // Validate the result
        if (result.geometry.type !== 'Polygon') {
            console.error('Result is not a valid Polygon.');
            return null;
        }
        return result;
    }
    // If no condition matches, just return original
    return original;
};
/**
 * Create a buffered polygon around a point, line, or polygon
 * @param geometry - A GeoJSON Feature (Point, LineString, or Polygon) or a Google Maps object
 * @param radius - The buffer distance in kilometers (negative values create a buffer inside the polygon)
 * @param options - Additional options for the buffer operation
 * @returns A GeoJSON Feature<Polygon> representing the buffered area
 */
TurfUtils.createBuffer = (geometry, radius, options) => {
    try {
        // Set default options
        const bufferOptions = Object.assign({ units: 'kilometers', steps: 64 }, options);
        let feature;
        // Handle different input types
        if (Array.isArray(geometry)) {
            // Handle array of coordinates (LineString or Polygon)
            if (Array.isArray(geometry[0])) {
                // This is an array of arrays - likely a polygon
                feature = (0, helpers_1.polygon)(geometry.map(ring => 
                // @ts-ignore - we already check if ring is a array
                ring.map(p => [p.lng, p.lat])));
            }
            else {
                // This is a simple array - likely a LineString
                feature = (0, helpers_1.lineString)(geometry.map(p => [p.lng, p.lat]));
            }
        }
        else if ('lat' in geometry && 'lng' in geometry) {
            // This is a single LatLngLiteral - treat as a point
            feature = (0, helpers_1.point)([geometry.lng, geometry.lat]);
        }
        else {
            // This is already a GeoJSON Feature
            feature = geometry;
        }
        // Create the buffer
        const buffered = (0, buffer_1.default)(feature, radius, bufferOptions);
        // Validate the result
        if (!buffered || buffered.type !== 'Feature' || buffered.geometry.type !== 'Polygon') {
            console.error('Failed to create a valid buffer.');
            return null;
        }
        return buffered;
    }
    catch (error) {
        console.error('Error creating buffer:', error);
        return null;
    }
};
/**
 * Checks if a coordinate is within a polygon
 * @param coordinate - A coordinate as a LatLngLiteral or [lng, lat] array
 * @param polygon - A GeoJSON polygon or Google Maps polygon paths
 * @returns Boolean indicating whether the point is inside the polygon
 */
TurfUtils.isCoordinateWithinPolygon = (coordinate, polygon) => {
    try {
        // Convert coordinate to a Turf point
        let turfPoint;
        if (Array.isArray(coordinate)) {
            // If coordinate is already [lng, lat]
            turfPoint = (0, helpers_1.point)(coordinate);
        }
        else {
            // If coordinate is google.maps.LatLngLiteral
            turfPoint = (0, helpers_1.point)([coordinate.lng, coordinate.lat]);
        }
        // Convert polygon to a Turf polygon if it's not already
        let turfPolygon;
        if (Array.isArray(polygon)) {
            // If polygon is a Google Maps path
            turfPolygon = _a.toTurfPolygon(polygon);
        }
        else {
            // If polygon is already a Turf feature
            turfPolygon = polygon;
        }
        // Check if the point is inside the polygon
        return (0, boolean_point_in_polygon_1.default)(turfPoint, turfPolygon);
    }
    catch (error) {
        console.error('Error checking if coordinate is within polygon:', error);
        return false;
    }
};
/**
 * Resolves overlapping polygons by trimming the overlap area and dividing it between them.
 * This creates two new polygons that touch each other along the division line.
 *
 * @param poly1 - First polygon Feature<Polygon>
 * @param poly2 - Second polygon Feature<Polygon>
 * @param ratio - Optional ratio for dividing the overlap area (0.5 means equal split, 0.3 means 30% to poly1, 70% to poly2)
 * @returns An object containing the two adjusted polygons as LatLngLiteral arrays, or null if no overlap
 */
TurfUtils.resolveOverlappingPolygons = (poly1, poly2) => {
    try {
        // Ensure both polygons are valid (closed rings)
        const validatePolygon = (poly) => {
            if (!poly.geometry || !poly.geometry.coordinates || poly.geometry.coordinates.length === 0) {
                return false;
            }
            const outerRing = poly.geometry.coordinates[0];
            if (outerRing.length < 4) { // Need at least 4 points for a valid polygon (3 points + closing point)
                return false;
            }
            // Check if the first and last points are the same (closed ring)
            const firstPoint = outerRing[0];
            const lastPoint = outerRing[outerRing.length - 1];
            if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
                console.error("Polygon is not closed");
                return false;
            }
            return true;
        };
        if (!validatePolygon(poly1) || !validatePolygon(poly2)) {
            console.error("One or both polygons are invalid");
            return null;
        }
        // Check if polygons intersect
        if (!(0, boolean_intersects_1.default)(poly1, poly2)) {
            // Polygons don't overlap;
            return null;
        }
        try {
            // Calculate the intersection (overlap area)
            const overlapArea = (0, intersect_1.default)((0, helpers_1.featureCollection)([poly1, poly2]));
            if (!overlapArea) {
                return null; // no overlap
            }
            // Process the overlap area to divide it between the two polygons
            const processOverlapArea = (overlapPoly) => {
                try {
                    // If the overlap is a MultiPolygon, we can't process it directly
                    if (overlapPoly.geometry.type === 'MultiPolygon') {
                        return null;
                    }
                    // Create a concentric buffer approach to find a point far from edges
                    // Start with a negative buffer (erodes the polygon)
                    // The amount of buffer depends on the size of the polygon
                    const bounds = overlapPoly.bbox;
                    const maxDistance = bounds ?
                        Math.min(Math.abs(bounds[2] - bounds[0]), Math.abs(bounds[3] - bounds[1])) * 0.15 : 0.0001; // 15% of the smaller dimension
                    // Try to create a negative buffer (erosion)
                    let innerPolygon;
                    try {
                        innerPolygon = (0, buffer_1.default)(overlapPoly, -maxDistance, { units: 'kilometers' });
                    }
                    catch (e) {
                        // If buffer fails, try a different approach
                        innerPolygon = null;
                    }
                    // If we have an inner polygon, use its centroid, otherwise fall back to center of mass
                    let overlapCentroid;
                    if (innerPolygon) {
                        overlapCentroid = (0, centroid_1.default)(innerPolygon);
                    }
                    else {
                        // Try center of mass as an alternative
                        overlapCentroid = (0, center_of_mass_1.default)(overlapPoly);
                        // If center of mass fails or is outside the polygon, use pointOnFeature as last resort
                        if (!overlapCentroid || !(0, boolean_point_in_polygon_1.default)(overlapCentroid, overlapPoly)) {
                            overlapCentroid = (0, point_on_feature_1.default)(overlapPoly);
                        }
                    }
                    if (!overlapCentroid) {
                        throw new Error("Failed to find an optimal center point inside the overlap polygon");
                    }
                    const coordinates = overlapPoly.geometry.coordinates;
                    // Create difference polygons (original polygons minus the overlap area)
                    const poly1MinusOverlap = (0, difference_1.default)((0, helpers_1.featureCollection)([poly1, overlapPoly]));
                    const poly2MinusOverlap = (0, difference_1.default)((0, helpers_1.featureCollection)([poly2, overlapPoly]));
                    if (!poly1MinusOverlap || !poly2MinusOverlap) {
                        throw new Error("Polygon difference calculation failed");
                    }
                    // Overlap polygon should only have two points that are within both original polygons
                    const dividerLinePoints = coordinates[0].map((coord) => {
                        const withinPolygon = _a.isCoordinateWithinPolygon(coord, poly1MinusOverlap) && _a.isCoordinateWithinPolygon(coord, poly2MinusOverlap);
                        if (withinPolygon) {
                            return coord;
                        }
                        return null;
                    }).filter(coord => coord !== null);
                    // Check if we have exactly two points for the divider line
                    if (dividerLinePoints.length !== 2) {
                        throw new Error("Invalid divider line points");
                    }
                    // Create division line through centroid
                    const divisionLine = (0, helpers_1.lineString)([dividerLinePoints[0], overlapCentroid.geometry.coordinates, dividerLinePoints[1]]);
                    // Create a small buffer around the division line
                    const divisionBuffer = (0, buffer_1.default)(divisionLine, 0.000001, { units: 'kilometers' });
                    if (!divisionBuffer) {
                        throw new Error("Division buffer creation failed");
                    }
                    // Split the overlap area using the division line
                    const overlapPart1 = (0, difference_1.default)((0, helpers_1.featureCollection)([overlapPoly, divisionBuffer]));
                    if (!overlapPart1) {
                        console.error("Failed to divide overlap area - part 1: ", overlapPart1);
                        return null;
                    }
                    // Use the division buffer to split the overlap into two parts
                    const intersection = (0, intersect_1.default)((0, helpers_1.featureCollection)([overlapPoly, divisionBuffer]));
                    if (!intersection) {
                        console.error("Failed to compute intersection with division buffer");
                        return null;
                    }
                    const overlapPart2 = (0, difference_1.default)((0, helpers_1.featureCollection)([overlapPoly, overlapPart1]));
                    if (!overlapPart2) {
                        console.error("Failed to divide overlap area - part 2: ", overlapPart2);
                        return null;
                    }
                    // Determine which part goes with which polygon
                    // Assign parts based on proximity to original polygon centroids
                    const poly1Centroid = (0, centroid_1.default)(poly1MinusOverlap);
                    const poly2Centroid = (0, centroid_1.default)(poly2MinusOverlap);
                    const part1Centroid = (0, centroid_1.default)(overlapPart1);
                    const part2Centroid = (0, centroid_1.default)(overlapPart2);
                    if (!poly1Centroid || !poly2Centroid || !part1Centroid || !part2Centroid) {
                        throw new Error("Centroid calculation failed for one or more polygons");
                    }
                    // Calculate distances between centroids
                    const dist1To1 = _a.calculateDistance(poly1Centroid.geometry.coordinates, part1Centroid.geometry.coordinates);
                    const dist1To2 = _a.calculateDistance(poly1Centroid.geometry.coordinates, part2Centroid.geometry.coordinates);
                    // Assign parts based on proximity
                    let newPoly1, newPoly2;
                    if (dist1To1 <= dist1To2) {
                        // Part1 is closer to Poly1
                        newPoly1 = (0, union_1.default)((0, helpers_1.featureCollection)([poly1MinusOverlap, overlapPart1]));
                        newPoly2 = (0, union_1.default)((0, helpers_1.featureCollection)([poly2MinusOverlap, overlapPart2]));
                    }
                    else {
                        // Part2 is closer to Poly1
                        newPoly1 = (0, union_1.default)((0, helpers_1.featureCollection)([poly1MinusOverlap, overlapPart2]));
                        newPoly2 = (0, union_1.default)((0, helpers_1.featureCollection)([poly2MinusOverlap, overlapPart1]));
                    }
                    if (!newPoly1 || !newPoly2) {
                        throw new Error("Failed to create new polygons");
                    }
                    // Convert to Google Maps format
                    const googlePoly1 = _a.toLatLngLiteral(newPoly1.geometry);
                    const googlePoly2 = _a.toLatLngLiteral(newPoly2.geometry);
                    // there should only be one path
                    return { polygon1: googlePoly1[0], polygon2: googlePoly2[0] };
                }
                catch (error) {
                    console.error('Error processing overlap area:', error);
                    // defaulting to assigning the overlap area to the first polygon
                    const poly2MinusOverlap = (0, difference_1.default)((0, helpers_1.featureCollection)([poly2, overlapPoly]));
                    const poly1Coords = _a.toLatLngLiteral(overlapArea.geometry);
                    const poly2Coords = poly2MinusOverlap ? _a.toLatLngLiteral(poly2MinusOverlap.geometry) : [];
                    return { polygon1: poly1Coords[0], polygon2: poly2Coords[0] };
                }
            };
            let result = null;
            if (overlapArea.geometry.type === 'MultiPolygon') {
                // For MultiPolygon overlaps, process each polygon individually
                const polygons = [];
                // Convert each polygon in the MultiPolygon to a Feature<Polygon>
                overlapArea.geometry.coordinates.forEach(coords => {
                    polygons.push((0, helpers_1.polygon)(coords));
                });
                // Process each overlap polygon individually
                // We'll need to merge the results from each individual processing
                let combinedPoly1 = [];
                let combinedPoly2 = [];
                for (const poly of polygons) {
                    const polyResult = processOverlapArea(poly);
                    if (polyResult) {
                        // First polygon results
                        if (!combinedPoly1.length) {
                            combinedPoly1 = polyResult.polygon1;
                        }
                        else if (polyResult.polygon1.length) {
                            // Convert to Turf.js polygons for union
                            const poly1Feature = _a.toTurfPolygon([combinedPoly1]);
                            const newPoly1Feature = _a.toTurfPolygon([polyResult.polygon1]);
                            // Union the polygons
                            const unionResult = (0, union_1.default)((0, helpers_1.featureCollection)([poly1Feature, newPoly1Feature]));
                            if (unionResult && unionResult.geometry.type === 'Polygon') {
                                // Convert back to Google Maps format
                                combinedPoly1 = unionResult.geometry.coordinates[0].map(([lng, lat]) => ({ lat, lng }));
                            }
                        }
                        // Second polygon results
                        if (!combinedPoly2.length) {
                            combinedPoly2 = polyResult.polygon2;
                        }
                        else if (polyResult.polygon2.length) {
                            // Convert to Turf.js polygons for union
                            const poly2Feature = _a.toTurfPolygon([combinedPoly2]);
                            const newPoly2Feature = _a.toTurfPolygon([polyResult.polygon2]);
                            // Union the polygons
                            const unionResult = (0, union_1.default)((0, helpers_1.featureCollection)([poly2Feature, newPoly2Feature]));
                            if (unionResult && unionResult.geometry.type === 'Polygon') {
                                // Convert back to Google Maps format
                                combinedPoly2 = unionResult.geometry.coordinates[0].map(([lng, lat]) => ({ lat, lng }));
                            }
                        }
                    }
                }
                if (combinedPoly1.length && combinedPoly2.length) {
                    result = { polygon1: combinedPoly1, polygon2: combinedPoly2 };
                }
            }
            else if (overlapArea.geometry.type === 'Polygon') {
                // For Polygon overlaps, process directly
                // Cast to the correct type since we've confirmed it's a Polygon
                const polyOverlap = overlapArea;
                result = processOverlapArea(polyOverlap);
                if (result) {
                    // If processing was successful, return the result
                    return result;
                }
            }
        }
        catch (err) {
            console.error("Error resolving overlapping polygons:", err);
        }
        // If all else fails, return null
        return null;
    }
    catch (error) {
        console.error("Error resolving overlapping polygons:", error);
        return null;
    }
};
//# sourceMappingURL=TurfUtils.js.map