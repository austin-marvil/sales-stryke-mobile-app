import { Feature, Polygon, MultiPolygon, Point, LineString } from 'geojson';
import { LatLngLiteral, BufferOptions } from './geospatial.types';
/**
 * Utility functions for working with Turf.js
 */
export declare class TurfUtils {
    /**
     * Calculate the Euclidean distance between two points
     */
    private static calculateDistance;
    /**
     * Convert lat/lng coordinates to a Turf.js polygon
     */
    static toTurfPolygon: (rings: LatLngLiteral[][]) => Feature<Polygon, import("geojson").GeoJsonProperties>;
    /**
     * Convert a GeoJSON polygon to lat/lng coordinates
     */
    static toLatLngLiteral: (geo: GeoJSON.Polygon | GeoJSON.MultiPolygon) => LatLngLiteral[][];
    /**
     * Update a polygon with a hole
     */
    static updatePolygonWithHole: (original: Feature<Polygon>, newHole: Feature<Polygon>) => Feature<Polygon> | null;
    /**
     * Create a buffered polygon around a point, line, or polygon
     * @param geometry - A GeoJSON Feature (Point, LineString, or Polygon) or a Google Maps object
     * @param radius - The buffer distance in kilometers (negative values create a buffer inside the polygon)
     * @param options - Additional options for the buffer operation
     * @returns A GeoJSON Feature<Polygon> representing the buffered area
     */
    static createBuffer: (geometry: Feature<Point | LineString | Polygon> | LatLngLiteral | LatLngLiteral[] | LatLngLiteral[][], radius: number, options?: BufferOptions) => Feature<Polygon> | null;
    /**
     * Checks if a coordinate is within a polygon
     * @param coordinate - A coordinate as a LatLngLiteral or [lng, lat] array
     * @param polygon - A GeoJSON polygon or Google Maps polygon paths
     * @returns Boolean indicating whether the point is inside the polygon
     */
    static isCoordinateWithinPolygon: (coordinate: LatLngLiteral | [number, number], polygon: Feature<Polygon | MultiPolygon> | LatLngLiteral[][]) => boolean;
    /**
     * Resolves overlapping polygons by trimming the overlap area and dividing it between them.
     * This creates two new polygons that touch each other along the division line.
     *
     * @param poly1 - First polygon Feature<Polygon>
     * @param poly2 - Second polygon Feature<Polygon>
     * @param ratio - Optional ratio for dividing the overlap area (0.5 means equal split, 0.3 means 30% to poly1, 70% to poly2)
     * @returns An object containing the two adjusted polygons as LatLngLiteral arrays, or null if no overlap
     */
    static resolveOverlappingPolygons: (poly1: Feature<Polygon>, poly2: Feature<Polygon>) => {
        polygon1: LatLngLiteral[];
        polygon2: LatLngLiteral[];
    } | null;
}
