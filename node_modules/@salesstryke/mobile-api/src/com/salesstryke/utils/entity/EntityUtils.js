"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityUtils = void 0;
const data_1 = require("../../data");
const EntityManager_1 = require("../../data/EntityManager");
const entity_1 = require("../../data/entity");
const EntityWebReflectionUtils_1 = require("../../jsonApi/util/EntityWebReflectionUtils");
const log_1 = require("../log");
const LogManager_1 = require("../log/LogManager");
const IsString_1 = require("../object/IsString");
const NAMESPACE = "com.salesstryke.utils.entity.EntityUtils";
const LOGGER = LogManager_1.LogManager.getLogger(NAMESPACE);
LOGGER.setLogLevel(log_1.Level.WARNING);
class MetaData {
    constructor() {
        this.namespace = 'com.salesstryke.utils.entity.EntityUtils';
    }
}
class EntityUtils {
    /**
     * Sets the mutated flag for each attribute that is not null.
     * @param p
     * @returns
     */
    static getAsMutated(p) {
        let asMutated = null;
        let className_s = p.entity.getClassName();
        let entityWrapper = EntityManager_1.EntityManager.getInstance().getEntityWrapperByNamespace(className_s);
        if (entityWrapper) {
            let attributes = entityWrapper.getAllAttributes();
            let attributeIndex_i = 0;
            let attributeSize_i = attributes.length;
            // let deepClone : any       = structuredClone(p.entity);
            for (attributeIndex_i = 0; attributeIndex_i < attributeSize_i; attributeIndex_i++) {
                let attribute = attributes[attributeIndex_i];
                let name = attribute.getTypeScriptAttributeName();
                let listMethodName = attribute.getAddListItemMethodName();
                let isListMethod = (listMethodName.length > 0) ? true : false;
                if (LOGGER.isInfoEnabled()) {
                    LOGGER.logInfo({ message: `attribute name: ${name}`, methodName: this.getAsMutated.name });
                }
                if (name === 'roles') {
                    // attribute = attribute;
                }
                if (attribute.getTypeScriptGetterMethodName().includes('_setRelationshipPersistableType')) {
                    // attribute = attribute;
                }
                if (attribute.getIsMongoPersistable()) {
                    let value_any = EntityWebReflectionUtils_1.EntityWebReflectionUtils.getValue(attribute, p.entity);
                    if (value_any) {
                        if (isListMethod) {
                            //let persistanceType : PersistenceType.ATTACH;
                            // need to access the attribute value directly to reset.
                            let entity_any = p.entity;
                            entity_any[name] = [];
                            let value_ary = value_any;
                            let valueIndex_i = 0;
                            let valueSize_i = value_ary.length;
                            for (valueIndex_i = 0; valueIndex_i < valueSize_i; valueIndex_i++) {
                                let listValue_any = value_ary[valueIndex_i];
                                EntityWebReflectionUtils_1.EntityWebReflectionUtils.setValueFromAny(p.entity, listValue_any, attribute, data_1.PersistenceType.ATTACH.getId());
                            }
                        }
                        else {
                            EntityWebReflectionUtils_1.EntityWebReflectionUtils.setValueFromAny(p.entity, null, attribute);
                            EntityWebReflectionUtils_1.EntityWebReflectionUtils.setValueFromAny(p.entity, value_any, attribute);
                        }
                    }
                }
            }
            asMutated = p.entity;
        }
        return (asMutated);
    }
    static getAsZodSchema(p) {
        let namespace = p.entity.getClassName();
        // let entityWrapper   : EntityWrapper | null = EntityManager.getInstance().getEntityWrapperByNamespace(namespace);
        // let schemaValidator : ZodRawShape = {};
        // if(entityWrapper)
        // {
        //     let attributes  : Array<Attribute> = entityWrapper.getValidatorAttributes();
        //     let index_i     : number = 0;
        //     let size_i      : number = attributes.length;
        //     for(index_i = 0; index_i < size_i; index_i++)
        //     {
        //         let attribute     : Attribute   = attributes[index_i];
        //         let attributeName : string      = attribute.getTypeScriptAttributeName();
        //         let validator     : ZodBoolean | ZodDate | ZodNumber | ZodString | undefined
        //                                         = attribute.getValidator();
        //         if (validator instanceof z.ZodType) {
        //             schemaValidator[attributeName] = validator;
        //         }
        //     }   
        // }
        // let zodSchema : ZodObject<T> = z.object(schemaValidator) as ZodObject<T>;
        // return(zodSchema);
        return EntityManager_1.EntityManager.getInstance().getEntityZodSchemaByNameSpace(namespace);
    }
    static getZodValidator(p) {
        let namespace = p.entity.getClassName();
        let entityWrapper = EntityManager_1.EntityManager.getInstance().getEntityWrapperByNamespace(namespace);
        let zodValidator = undefined;
        if (entityWrapper) {
            let attribute = entityWrapper.getAttributeByName(p.attributeName);
            if (attribute) {
                switch (attribute.getDataType()) {
                    case entity_1.DataType.BOOLEAN:
                        zodValidator = attribute.getValidator();
                        break;
                    case entity_1.DataType.DATE:
                        zodValidator = attribute.getValidator();
                        break;
                    case entity_1.DataType.CURRENCY:
                    case entity_1.DataType.FLOAT:
                    case entity_1.DataType.INTEGER:
                    case entity_1.DataType.NUMBER:
                    case entity_1.DataType.REAL:
                        zodValidator = attribute.getValidator();
                        break;
                    case entity_1.DataType.FORIEGN_KEY:
                    case entity_1.DataType.ID:
                    case entity_1.DataType.JSON_STRING:
                    case entity_1.DataType.SECURE_STRING:
                    case entity_1.DataType.STRING:
                        zodValidator = attribute.getValidator();
                        break;
                    default:
                        throw new Error(`${namespace}.${p.attributeName} DataType not handeled correctly.`);
                }
            }
        }
        return (zodValidator);
    }
    /**
     * Takes a string and turns it into an Object of type any.
     */
    static jsonStringParser(p) {
        const encodedURI = encodeURI(p.value);
        let value = JSON.parse(encodedURI);
        if ((0, IsString_1.default)(value)) {
            value = JSON.parse(value);
        }
        return (value);
    }
    /**
     * Takes a string, returns an object.
     * @param p
     * @returns
     */
    static jsonStringGetter(p) {
        try {
            if (p.value && p.value !== '') {
                // const decodedURI = decodeURI(p.value);
                // let value : any = JSON.parse(decodedURI);
                let value = JSON.parse(p.value);
                if ((0, IsString_1.default)(value)) {
                    value = JSON.parse(value);
                }
                return (value);
            }
        }
        catch (error_any) {
            let error = error_any;
            LOGGER.logError({ message: `object to JSON error, object ${p.value}`, methodName: this.call.name });
            LOGGER.logError({ message: `${error.message} ${error.stack}`, methodName: this.call.name });
            throw error;
        }
        return ('');
    }
    static isListEqual(list1, list2) {
        // Check if arrays have the same length
        if (!list1 || !list2)
            return false;
        if (list1.length !== list2.length)
            return false;
        // Create sets of IDs from both arrays
        const aIds = new Set(list1.map((row) => row.getId()));
        const bIds = new Set(list2.map((row) => row.getId()));
        // Check if the sets are equal (i.e., they contain the same unique IDs)
        if (aIds.size !== bIds.size)
            return false;
        // Check if every element in a is present in b and vice versa
        for (let id of aIds) {
            if (!bIds.has(id)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Takes an object, returns a string
     * @param p
     */
    static jsonStringSetter(p) {
        if (p.value) {
            const toString = JSON.stringify(p.value);
            if (LOGGER.isInfoEnabled()) {
                let toJson = JSON.parse(toString);
                LOGGER.logInfo({ message: `${toString}`, methodName: this.jsonStringSetter.name });
            }
            //const encodedURI : string = encodeURI(toString);
            return (toString);
        }
        return ('');
    }
}
exports.EntityUtils = EntityUtils;
EntityUtils.metaDataForEntityUtils = new MetaData();
//# sourceMappingURL=EntityUtils.js.map