"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateUtils = void 0;
const InValidDateError_1 = require("../errors/InValidDateError");
const IsDate_1 = require("./object/IsDate");
const IsString_1 = require("./object/IsString");
const date_fns_tz_1 = require("date-fns-tz");
const date_fns_1 = require("date-fns");
function pad(number_i_p) {
    let pad_s_m = "00";
    let size_i_m = 2;
    let temp_s_m = "00" + number_i_p;
    pad_s_m = temp_s_m.substr(temp_s_m.length - size_i_m);
    return (pad_s_m);
}
function zoneOffsetIndicator(number_i_p) {
    if (number_i_p >= 0) {
        return ("+");
    }
    else {
        return ("-");
    }
}
const NAMESPACE = "com.salesstryke.utils.DateUtils";
class DateUtils {
    /**
     * Helper function to ensure input is a valid Date object
     * @param input Input that may or may not be a Date object
     * @returns Valid Date object from input, or null if invalid
     */
    static ensureValidDate(input) {
        // If input is already a valid Date, return it
        if (input instanceof Date && !isNaN(input.getTime())) {
            return input;
        }
        // Try to convert to Date if input is not null/undefined
        if (input != null) {
            const convertedDate = new Date(input);
            // Check if conversion resulted in a valid date
            if (!isNaN(convertedDate.getTime())) {
                return convertedDate;
            }
        }
        // Return null for invalid inputs
        return null;
    }
    /**
     * Takes in a valid Date object and returns a string 'YYYY-MM-DD'
     * @param date_dt_p
     */
    static dateObjectToDashedYYYYMMDD(date_dt_p) {
        let date_s_m = null;
        let date_dt_m = null;
        let day_i_m = -1;
        let exists_b_m = false;
        let hour_i_m = -1;
        let minute_i_m = -1;
        let month_i_m = -1;
        let second_i_m = -1;
        let year_i_m = -1;
        let zoneOffset_i_m = -1;
        if ((0, IsDate_1.default)(date_dt_p)) {
            date_dt_m = date_dt_p;
            if (date_dt_m != null) {
                day_i_m = date_dt_m.getDate(); // 1 based day of month.
                hour_i_m = date_dt_m.getHours();
                minute_i_m = date_dt_m.getMinutes();
                month_i_m = date_dt_m.getMonth() + 1; // 0 based months.
                second_i_m = date_dt_m.getSeconds();
                year_i_m = date_dt_m.getFullYear();
                zoneOffset_i_m = date_dt_m.getTimezoneOffset() / 60;
                date_s_m = year_i_m + "-" + pad(month_i_m) + "-" + pad(day_i_m);
            }
        }
        else if ((0, IsString_1.default)(date_dt_p)) {
            date_s_m = date_dt_p.toString();
            if (date_s_m != null) {
                date_s_m = date_s_m.substring(0, 10);
            }
        }
        return (date_s_m);
    }
    static dateToString(p) {
        let date_s_m = null;
        let date_dt_m = null;
        let day_i_m = -1;
        let exists_b_m = false;
        let hour_i_m = -1;
        let minute_i_m = -1;
        let month_i_m = -1;
        let second_i_m = -1;
        let year_i_m = -1;
        let zoneOffset_i_m = -1;
        if ((0, IsDate_1.default)(p.date)) {
            day_i_m = p.date.getDate(); // 1 based day of month.
            hour_i_m = p.date.getHours();
            minute_i_m = p.date.getMinutes();
            month_i_m = p.date.getMonth() + 1; // 0 based months.
            second_i_m = p.date.getSeconds();
            year_i_m = p.date.getFullYear();
            zoneOffset_i_m = p.date.getTimezoneOffset() / 60;
            date_s_m = year_i_m + "-" + pad(month_i_m) + "-" + pad(day_i_m);
            date_s_m += "T" + pad(hour_i_m) + ":" + pad(minute_i_m) + ":" + pad(second_i_m);
            date_s_m += zoneOffsetIndicator(zoneOffset_i_m) + pad(zoneOffset_i_m) + ":00";
        }
        return (date_s_m);
    }
    // public static dateToString(date: Date | null): string
    // {
    //     let value_s:    string = '';
    //     if(date !== undefined && date !== null)
    //     {
    //         value_s     = date.toString();
    //     }
    //     return(value_s);
    // }
    static getDateAs12HHColonMM(date_dt_p, showAmPm_b_p = false) {
        let amPm_s_m = "";
        let date_s_m = null;
        let date_dt_m = null;
        let day_i_m = -1;
        let exists_b_m = false;
        let hour_i_m = -1;
        let minute_i_m = -1;
        let month_i_m = -1;
        let second_i_m = -1;
        let time_s_m = null;
        let year_i_m = -1;
        let zoneOffset_i_m = -1;
        if ((0, IsDate_1.default)(date_dt_p)) {
            date_dt_m = date_dt_p;
            if (date_dt_m != null) {
                hour_i_m = date_dt_m.getHours();
                if (showAmPm_b_p) {
                    amPm_s_m = (hour_i_m >= 12) ? "PM" : "AM";
                }
                hour_i_m = (hour_i_m) % 12;
                if (hour_i_m == 0) {
                    hour_i_m = 12;
                    amPm_s_m = "PM";
                }
                minute_i_m = date_dt_m.getMinutes();
                time_s_m = pad(hour_i_m) + ":" + pad(minute_i_m) + " " + amPm_s_m;
            }
        }
        else if ((0, IsString_1.default)(date_dt_p)) {
            date_s_m = date_dt_p.toString();
            if (date_s_m != null) {
                date_s_m = date_s_m.substring(0, 10);
            }
        }
        return (time_s_m);
    }
    /**
     * Given a Date object, returns HH:MM
     * @param date_dt_p
     */
    static getDateAs24HHColonMM(date_dt_p, showAmPm_b_p = false) {
        let amPm_s_m = "";
        let date_s_m = null;
        let date_dt_m = null;
        let day_i_m = -1;
        let exists_b_m = false;
        let hour_i_m = -1;
        let minute_i_m = -1;
        let month_i_m = -1;
        let second_i_m = -1;
        let time_s_m = null;
        let year_i_m = -1;
        let zoneOffset_i_m = -1;
        if ((0, IsDate_1.default)(date_dt_p)) {
            date_dt_m = date_dt_p;
            if (date_dt_m != null) {
                hour_i_m = date_dt_m.getHours();
                if (showAmPm_b_p) {
                    amPm_s_m = (hour_i_m >= 12) ? "PM" : "AM";
                }
                minute_i_m = date_dt_m.getMinutes();
                time_s_m = pad(hour_i_m) + ":" + pad(minute_i_m) + " " + amPm_s_m;
            }
        }
        else if ((0, IsString_1.default)(date_dt_p)) {
            date_s_m = date_dt_p.toString();
            if (date_s_m != null) {
                date_s_m = date_s_m.substring(0, 10);
            }
        }
        return (time_s_m);
    }
    static isISO8601(dateString) {
        const isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})$/;
        return isoRegex.test(dateString);
    }
    static isTimeWithin(p) {
        let isTimeWithin_b = false;
        let time1_n = p.time1.getTime();
        let time2_n = p.time2.getTime();
        let testTimeMili_n = p.isWithinMinutes * 1000;
        if (time1_n > time2_n) {
            time2_n = time1_n;
            time1_n = p.time2.getTime();
        }
        let timeDiff = time1_n - time2_n;
        timeDiff = Math.abs(timeDiff);
        if (timeDiff < testTimeMili_n) {
            isTimeWithin_b = true;
        }
        return (isTimeWithin_b);
    }
    static stringToZonedDateTime(ISODateString) {
        let result = null;
        const parsedDate = (0, date_fns_1.parseISO)(ISODateString);
        if (isNaN(parsedDate.getTime())) {
            return null;
        }
        if (/[Z+-]/.test(ISODateString)) {
            // extract the timezone from the string or use local timezone
            let timezone;
            if (ISODateString.includes('Z')) {
                timezone = 'UTC';
            }
            else {
                // use the browser's local timezone
                timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            }
            // convert the zoned time to a Date object
            result = (0, date_fns_tz_1.zonedTimeToUtc)(parsedDate, timezone);
        }
        else {
            // if no timezone info is present, just use the parsed date
            result = parsedDate;
        }
        return result;
    }
    /**
     * convert Date to ISO 8601 formatted datetime string
     *
     * use Intl.DateTimeFormat().resolvedOptions().timeZone to local timezone
     */
    static zonedDateTimeToString(object_p, timeZone = 'America/Chicago') {
        return (0, date_fns_tz_1.formatInTimeZone)(object_p, timeZone, "yyyy-MM-dd'T'HH:mm:ssXXX" // ISO 8601 format with timezone offset
        );
    }
    static stringToDate(p) {
        // let [dateValues, timeWithMilliValues]:      Array<string>   = p.dateAsString.split('T');
        // let [timeValues, milliValues]:              Array<string>   = timeWithMilliValues.split('.');
        // let [year, months, days]:                   Array<string>   = dateValues.split('-');
        // let [hours, minutes, seconds]:              Array<string>   = timeValues.split(':');
        // let date:                                   Date            = new Date(+year, +months - 1, +days, +hours, +minutes, +seconds);
        // return(date);
        let date = new Date();
        let hasError = false;
        if (this.isISO8601(p.dateAsString)) {
            date = new Date(p.dateAsString);
            return (date);
        }
        try {
            let dateTimeParts = p.dateAsString.split('T').map(value => value.replace(/[^0-9.:-]/g, ''));
            let dateValues = dateTimeParts[0].split('-');
            let timeSection = dateTimeParts[1].split('+')[0]; // Stripping timezone part
            let timeValues = timeSection.split(':');
            let secondParts = timeValues[2].split('.'); // Splitting seconds and milliseconds
            let seconds = +secondParts[0];
            let milliseconds = secondParts.length > 1 ? +secondParts[1] : 0; // Check if milliseconds exist
            date = new Date(+dateValues[0], +dateValues[1] - 1, // Month is zero-based in JS Date
            +dateValues[2], +timeValues[0], +timeValues[1], seconds, milliseconds // Adding milliseconds
            );
        }
        catch (error_any) {
            hasError = true;
        }
        if (hasError || isNaN(date.getTime())) {
            throw new InValidDateError_1.InvalidDateError({ value: `${p.dateAsString}`, namespace: NAMESPACE, methodName: this.stringToDate.name });
        }
        return (date);
    }
    /**
     * Returns: YYYY-MM-DDTHH:mm:ss
     * @param date
     * @returns
     */
    static dateToYYYYMMDDTHHMMSS(date) {
        let value_s = '';
        if (date !== undefined && date !== null) {
            let year = date.getFullYear();
            let months = date.getMonth();
            let days = date.getDate();
            let hours = date.getHours();
            let minutes = date.getMinutes();
            let seconds = date.getSeconds();
            let date_s = `${year}-${(months + 1).toString().padStart(2, '0')}-${days.toString().padStart(2, '0')}`;
            let time_s = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            value_s = `${date_s}T${time_s}`;
        }
        return (value_s);
    }
    static daysAgo(date, daysAgo) {
        const pastDate = new Date();
        pastDate.setDate(date.getDate() - daysAgo);
        return pastDate;
    }
    static isDateExipred(date) {
        const currentDate = new Date();
        const inputDate = new Date(date);
        return inputDate < currentDate;
    }
    static displayFormat(date) {
        if (typeof date === 'string') {
            date = new Date(date);
        }
        return (0, date_fns_1.format)(date, 'MM/dd/yyyy');
    }
    /**
     * Format a date using date-fns format patterns.
     *
     * @param date The date to format (can be a Date object or a string that can be parsed to a Date)
     * @param format The format string pattern to apply
     * @returns The formatted date string
     *
     * @example
     * // Returns "September 23, 2025"
     * DateUtils.format(new Date(), 'MMMM d, yyyy')
     *
     * Common format patterns:
     * - 'MM/dd/yyyy' -> 09/23/2025 (US date format)
     * - 'dd/MM/yyyy' -> 23/09/2025 (European date format)
     * - 'yyyy-MM-dd' -> 2025-09-23 (ISO date format)
     * - 'MMMM d, yyyy' -> September 23, 2025
     * - 'MMM d, yyyy' -> Sep 23, 2025
     * - 'EEEE, MMMM d, yyyy' -> Monday, September 23, 2025
     * - 'h:mm a' -> 2:30 PM (12-hour time)
     * - 'HH:mm' -> 14:30 (24-hour time)
     * - 'MMMM d' -> September 23
     *
     * Full pattern reference:
     * Year: y (25), yy (25), yyyy (2025)
     * Month: M (9), MM (09), MMM (Sep), MMMM (September)
     * Day: d (1), dd (01), D (day of year)
     * Weekday: E (day number), EEEE (Monday), EEEEE (M)
     * Hour: H (0-23), HH (00-23), h (1-12), hh (01-12)
     * Minute/Second: m, mm, s, ss
     * AM/PM: a (AM/PM)
     */
    static format(date, format) {
        if (typeof date === 'string') {
            date = new Date(date);
        }
        return (0, date_fns_1.format)(date, format);
    }
    static setTimeFromDate(targetDate, referenceDate) {
        // Set the target date's hours and minutes based on the reference date
        targetDate.setHours(referenceDate.getHours(), referenceDate.getMinutes(), 0, 0);
        return targetDate;
    }
}
exports.DateUtils = DateUtils;
//# sourceMappingURL=DateUtils.js.map