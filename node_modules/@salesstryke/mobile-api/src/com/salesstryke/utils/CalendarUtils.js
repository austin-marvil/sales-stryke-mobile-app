"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalendarUtils = void 0;
const DateUtils_1 = require("./DateUtils");
const Calendar_type_1 = require("../types/Calendar.type");
const rrule_1 = require("rrule");
/**
 * Utility class for calendar-specific date operations
 */
class CalendarUtils {
    /**
     * Determines which occurrence of the weekday a specific date represents in its month.
     * For example, "the first Monday", "the third Friday", etc.
     *
     * @param date The date to check
     * @returns A number representing the occurrence (1 for first, 2 for second, etc.), or -1 for last
     */
    static getWeekdayOccurrenceInMonth(date) {
        const dayOfMonth = date.getDate();
        const dayOfWeek = date.getDay();
        const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
        const firstDayOfWeekInMonth = firstDayOfMonth.getDay();
        // Calculate the date of the first occurrence of this weekday in the month
        const daysUntilFirstOccurrence = (dayOfWeek - firstDayOfWeekInMonth + 7) % 7;
        const firstOccurrenceDate = daysUntilFirstOccurrence + 1;
        // Calculate which occurrence this is
        const occurrenceNumber = Math.ceil((dayOfMonth - firstOccurrenceDate + 1) / 7);
        // Check if it's the last occurrence of this weekday in the month
        const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
        // Calculate the date of the last occurrence of this weekday in the month
        let lastOccurrenceDate = firstOccurrenceDate;
        while (lastOccurrenceDate + 7 <= daysInMonth) {
            lastOccurrenceDate += 7;
        }
        if (dayOfMonth === lastOccurrenceDate) {
            return -1; // Indicates "last"
        }
        return occurrenceNumber;
    }
    /**
     * Gets a formatted string for the occurrence position in the month
     *
     * @param date The date to format
     * @param t Translation function
     * @returns A string like "first", "second", "third", "fourth", or "last"
     */
    static getFormattedOccurrence(date, t) {
        const occurrence = this.getWeekdayOccurrenceInMonth(date);
        if (occurrence === -1) {
            return {
                interval: -1,
                label: t('calendar:label.occurrenceEnum.last')
            };
        }
        const ordinalLabels = [
            t('calendar:label.occurrenceEnum.first'),
            t('calendar:label.occurrenceEnum.second'),
            t('calendar:label.occurrenceEnum.third'),
            t('calendar:label.occurrenceEnum.fourth')
        ];
        return {
            interval: occurrence,
            label: occurrence <= 4 ? ordinalLabels[occurrence - 1] : t('calendar:label.occurrenceEnum.last')
        };
    }
    /**
     * Gets the day of week name for a given date
     *
     * @param date The date to get the day name for
     * @param t Translation function
     * @returns Localized day name
     */
    static getDayOfWeekName(date, t) {
        const dayIndex = date.getDay();
        const weekdayKeys = [
            'calendar:label.WeekDayEnum.sunday',
            'calendar:label.WeekDayEnum.monday',
            'calendar:label.WeekDayEnum.tuesday',
            'calendar:label.WeekDayEnum.wednesday',
            'calendar:label.WeekDayEnum.thursday',
            'calendar:label.WeekDayEnum.friday',
            'calendar:label.WeekDayEnum.saturday'
        ];
        return t(weekdayKeys[dayIndex]);
    }
    /**
     * Gets the start and end dates for a calendar view based on the given date
     *
     * @param date The reference date
     * @param fullCalendarView If true, returns dates to fill a complete calendar grid (typically 35 days),
     *                         including days from adjacent months if needed. If false, returns just the current month range.
     * @returns An object with start and end dates for the calendar view
     */
    static getCalendarViewDates(date, fullCalendarView = false) {
        // Create a new date object to avoid mutating the original
        const viewDate = new Date(date);
        // Set to the first day of the month
        const firstDayOfMonth = new Date(viewDate.getFullYear(), viewDate.getMonth(), 1);
        // Set to the last day of the month
        const lastDayOfMonth = new Date(viewDate.getFullYear(), viewDate.getMonth() + 1, 0);
        if (!fullCalendarView) {
            // Return just the month range
            return {
                startDate: firstDayOfMonth,
                endDate: lastDayOfMonth
            };
        }
        // For full calendar view, determine the start date (Sunday of the week containing the 1st)
        // and end date (Saturday of the week containing the last day of month)
        // Get the day of week for the first day (0 = Sunday, 1 = Monday, etc.)
        const firstDayOfWeek = firstDayOfMonth.getDay();
        // Calculate the start date (go back to the previous Sunday)
        const startDate = new Date(firstDayOfMonth);
        startDate.setDate(firstDayOfMonth.getDate() - firstDayOfWeek);
        // Get the day of week for the last day
        const lastDayOfWeek = lastDayOfMonth.getDay();
        // Calculate the end date (go forward to the next Saturday)
        const endDate = new Date(lastDayOfMonth);
        endDate.setDate(lastDayOfMonth.getDate() + (6 - lastDayOfWeek));
        // February can be a 4x7 calendar grid therefore we do not forcefully add more days
        // to reach 35 days. This ensures the calendar view is accurate for the month. So we do not need the following check.
        // Ensure we have at least 35 days (5 weeks) for a consistent calendar grid
        // const daysDifference = Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
        // if (daysDifference < 35) {
        //     // Add an extra week to reach 35+ days
        //     endDate.setDate(endDate.getDate() + 7);
        // }
        return { startDate, endDate };
    }
    /**
     * Creates dynamic occurrence options for calendar events
     *
     * @param date The selected date
     * @param t Translation function
     * @returns Array of options for the occurrence dropdown
     */
    static getRecurrenceOptions(date, t) {
        if (!(date instanceof Date) || isNaN(date.getTime())) {
            // Invalid date provided to getRecurrenceOptions
            date = new Date(); // Fallback to current date
        }
        // Get formatted values for this date
        const dayOfWeek = this.getDayOfWeekName(date, t);
        const weekOfMonth = this.getFormattedOccurrence(date, t);
        const formattedDate = DateUtils_1.DateUtils.format(date, 'MMMM d');
        return [
            {
                label: t('calendar:label.occurrenceEnum.noRepeat'),
                value: JSON.stringify({
                    frequency: Calendar_type_1.CalendarRecurringTypeEnum.NONE,
                    interval: 1,
                    nth: 0,
                })
            },
            {
                label: t('calendar:label.occurrenceEnum.weekly', { day: dayOfWeek }),
                value: JSON.stringify({
                    frequency: Calendar_type_1.CalendarRecurringTypeEnum.WEEKLY,
                    interval: 1,
                    nth: 0, // 'nth' is not used for weekly recurrence
                })
            },
            {
                label: t('calendar:label.occurrenceEnum.monthly', {
                    occurrence: weekOfMonth.label,
                    day: dayOfWeek
                }),
                value: JSON.stringify({
                    frequency: Calendar_type_1.CalendarRecurringTypeEnum.MONTHLY,
                    interval: 1,
                    nth: weekOfMonth.interval, // Correct use of 'nth' for monthly recurrence
                })
            },
            {
                label: t('calendar:label.occurrenceEnum.annually', { date: formattedDate }),
                value: JSON.stringify({
                    frequency: Calendar_type_1.CalendarRecurringTypeEnum.ANNUALLY,
                    interval: 1,
                    nth: 0, // 'nth' is not used for yearly recurrence
                })
            }
        ];
    }
    /**
     * Generates RRule and associated dates based on recurrence options
     *
     * @param options Object containing all parameters for rule generation {@link TRRuleGeneratorOptions}
     *        - recurrence: The recurrence configuration (frequency, interval, etc.)
     *        - startDate: Start date for the recurrence range to calculate (Date object or date string)
     *        - endDate: End date for the recurrence range to calculate (Date object or date string)
     *        - excludeDates: Optional dates to exclude from recurrence pattern (Date objects, date strings, or array of either)
     *        - dtstart: Optional date to override RRule's dtstart (Date object or date string, defaults to startDate if not provided)
     *        - until: Optional date to override RRule's until (Date object or date string, defaults to endDate if not provided)
     * @returns Object containing RRule instance, RRuleSet (if exclusions exist), and generated dates
     *
     * All date inputs are automatically validated and converted to Date objects if they aren't already.
     * If startDate or endDate are invalid, they will default to the current date.
     * The dtstart and until parameters preserve null/undefined values if provided that way.
     */
    static generateRRule(options) {
        const { recurrence, startDate: inputStartDate, endDate: inputEndDate, excludeDates = [], dtstart: inputDtstart, until: inputUntil } = options;
        // Validate and convert date inputs
        const startDate = DateUtils_1.DateUtils.ensureValidDate(inputStartDate) || new Date();
        const endDate = DateUtils_1.DateUtils.ensureValidDate(inputEndDate) || new Date();
        // Keep dtstart and until as they are if null/undefined, otherwise validate
        const dtstart = inputDtstart != null ? DateUtils_1.DateUtils.ensureValidDate(inputDtstart) : inputDtstart;
        const until = inputUntil != null ? DateUtils_1.DateUtils.ensureValidDate(inputUntil) : inputUntil;
        // Handle different formats of excludeDates
        let processedExcludeDates = [];
        if (excludeDates) {
            if (excludeDates instanceof Array) {
                // If it's already an array of Dates or date-like objects
                processedExcludeDates = excludeDates.map(date => DateUtils_1.DateUtils.ensureValidDate(date)).filter(date => date !== null);
            }
            else if (typeof excludeDates === 'string') {
                // If it's a JSON string (from our recent changes)
                try {
                    const parsedDates = JSON.parse(excludeDates);
                    if (Array.isArray(parsedDates)) {
                        // Convert all items to Date objects, filter out invalid ones
                        processedExcludeDates = parsedDates
                            .map(dateItem => DateUtils_1.DateUtils.ensureValidDate(dateItem))
                            .filter(date => date !== null);
                    }
                }
                catch (e) {
                    // If JSON parsing fails, use empty array
                    processedExcludeDates = [];
                }
            }
            else if (typeof excludeDates === 'object') {
                // If it's an object (older format or other)
                const excludeDatesObj = excludeDates;
                if (Array.isArray(excludeDatesObj.data)) {
                    // Legacy format with data property - convert all items to Date objects
                    processedExcludeDates = excludeDatesObj.data
                        .map((dateItem) => DateUtils_1.DateUtils.ensureValidDate(dateItem))
                        .filter((date) => date !== null);
                }
            }
        }
        // Handle empty or invalid recurrence
        if (!recurrence) {
            return {
                rule: null,
                ruleSet: null,
                dates: [startDate],
            };
        }
        // Parse the recurrence object if it's a string (from select component)
        let recurrenceObj;
        try {
            recurrenceObj = typeof recurrence === 'string'
                ? JSON.parse(recurrence)
                : recurrence;
        }
        catch (e) {
            // If parsing fails, return single date
            return {
                rule: null,
                ruleSet: null,
                dates: [startDate],
            };
        }
        // If it's a non-recurring event, return empty rule with single date
        if (!recurrenceObj || recurrenceObj.frequency === Calendar_type_1.CalendarRecurringTypeEnum.NONE) {
            return {
                rule: null,
                ruleSet: null,
                dates: [startDate],
            };
        }
        let freq = rrule_1.RRule.WEEKLY;
        let byweekday = undefined;
        // Handle different recurrence types
        switch (recurrenceObj.frequency) {
            case Calendar_type_1.CalendarRecurringTypeEnum.WEEKLY:
                freq = rrule_1.RRule.WEEKLY;
                break;
            case Calendar_type_1.CalendarRecurringTypeEnum.MONTHLY:
                freq = rrule_1.RRule.MONTHLY;
                // For monthly recurrence, use the nth weekday
                // Get the reference date for determining the day of week
                // Always use startDate for consistency in determining the weekday pattern
                const dayOfWeek = startDate.getDay();
                switch (dayOfWeek) {
                    case 0:
                        byweekday = [rrule_1.RRule.SU.nth(recurrenceObj.nth)];
                        break;
                    case 1:
                        byweekday = [rrule_1.RRule.MO.nth(recurrenceObj.nth)];
                        break;
                    case 2:
                        byweekday = [rrule_1.RRule.TU.nth(recurrenceObj.nth)];
                        break;
                    case 3:
                        byweekday = [rrule_1.RRule.WE.nth(recurrenceObj.nth)];
                        break;
                    case 4:
                        byweekday = [rrule_1.RRule.TH.nth(recurrenceObj.nth)];
                        break;
                    case 5:
                        byweekday = [rrule_1.RRule.FR.nth(recurrenceObj.nth)];
                        break;
                    case 6:
                        byweekday = [rrule_1.RRule.SA.nth(recurrenceObj.nth)];
                        break;
                    default: byweekday = [rrule_1.RRule.WE.nth(recurrenceObj.nth)]; // Fallback to Wednesday
                }
                break;
            case Calendar_type_1.CalendarRecurringTypeEnum.ANNUALLY:
                freq = rrule_1.RRule.YEARLY;
                break;
            default:
                freq = rrule_1.RRule.WEEKLY;
        }
        // Determine the effective dtstart date
        let effectiveDtstart = dtstart !== null && dtstart !== void 0 ? dtstart : startDate;
        // For WEEKLY recurrence, we need special handling
        if (recurrenceObj.frequency === Calendar_type_1.CalendarRecurringTypeEnum.WEEKLY) {
            // For weekly recurrence, the byweekday should match startDate's day of week
            // regardless of what dtstart is
            const dayOfWeek = startDate.getDay();
            switch (dayOfWeek) {
                case 0:
                    byweekday = [rrule_1.RRule.SU];
                    break;
                case 1:
                    byweekday = [rrule_1.RRule.MO];
                    break;
                case 2:
                    byweekday = [rrule_1.RRule.TU];
                    break;
                case 3:
                    byweekday = [rrule_1.RRule.WE];
                    break;
                case 4:
                    byweekday = [rrule_1.RRule.TH];
                    break;
                case 5:
                    byweekday = [rrule_1.RRule.FR];
                    break;
                case 6:
                    byweekday = [rrule_1.RRule.SA];
                    break;
            }
        }
        // If dtstart is provided and has a different day of week than startDate,
        // we need to adjust it for consistent recurrence patterns
        if (dtstart && startDate.getDay() !== dtstart.getDay()) {
            // For monthly recurrences, the day of week is critical
            if (recurrenceObj.frequency === Calendar_type_1.CalendarRecurringTypeEnum.MONTHLY) {
                // Create a new date with dtstart's year/month/date but adjust to match startDate's day of week
                const targetDayOfWeek = startDate.getDay();
                const currentDayOfWeek = dtstart.getDay();
                const daysToAdjust = (targetDayOfWeek - currentDayOfWeek + 7) % 7;
                // Create adjusted date
                effectiveDtstart = new Date(dtstart);
                effectiveDtstart.setDate(effectiveDtstart.getDate() + daysToAdjust);
            }
        }
        // Create RRule object
        const ruleObject = {
            freq: freq,
            dtstart: effectiveDtstart, // Use adjusted dtstart
            until: until !== null && until !== void 0 ? until : endDate, // Use provided until or fallback to endDate
            interval: recurrenceObj.interval,
        };
        // Add byweekday if defined
        if (byweekday) {
            ruleObject.byweekday = byweekday;
        }
        // For weekly recurrence, ensure we get dates on the right day of the week
        if (recurrenceObj.frequency === Calendar_type_1.CalendarRecurringTypeEnum.WEEKLY) {
            // Always use startDate's day of week for weekly recurrence
            const dayOfWeek = startDate.getDay();
            // For weekly recurrence, explicitly set byweekday
            switch (dayOfWeek) {
                case 0:
                    ruleObject.byweekday = [rrule_1.RRule.SU];
                    break;
                case 1:
                    ruleObject.byweekday = [rrule_1.RRule.MO];
                    break;
                case 2:
                    ruleObject.byweekday = [rrule_1.RRule.TU];
                    break;
                case 3:
                    ruleObject.byweekday = [rrule_1.RRule.WE];
                    break;
                case 4:
                    ruleObject.byweekday = [rrule_1.RRule.TH];
                    break;
                case 5:
                    ruleObject.byweekday = [rrule_1.RRule.FR];
                    break;
                case 6:
                    ruleObject.byweekday = [rrule_1.RRule.SA];
                    break;
            }
        }
        // Create the base rule
        const rule = new rrule_1.RRule(ruleObject);
        // Process dates based on whether we have exclusions
        let dates;
        let ruleSet = null;
        if (processedExcludeDates && processedExcludeDates.length > 0) {
            // Create a RuleSet for handling exclusions
            const set = new rrule_1.RRuleSet();
            set.rrule(rule);
            // Add each excluded date to the ruleset
            processedExcludeDates.forEach(excludeDate => {
                set.exdate(excludeDate);
            });
            // Get all dates from the ruleset
            dates = set.all();
            ruleSet = set;
        }
        else {
            // No excluded dates, just use the rule
            dates = rule.all();
            // ruleSet remains null
        }
        // If no dates were generated but we expect some, force certain dates to appear
        if (dates.length === 0) {
            // Check if startDate and endDate fall on the same calendar day,
            // regardless of the time component or timezone offset
            const startDateDay = new Date(startDate).setHours(0, 0, 0, 0);
            const endDateDay = new Date(endDate).setHours(0, 0, 0, 0);
            const isSingleDayRange = startDateDay === endDateDay ||
                startDate.toDateString() === endDate.toDateString() ||
                // Check if they're the same day based on year, month, and day components
                (startDate.getFullYear() === endDate.getFullYear() &&
                    startDate.getMonth() === endDate.getMonth() &&
                    startDate.getDate() === endDate.getDate());
            if (isSingleDayRange) {
                // If we have a single-day range with no results, include the start date
                dates = [new Date(startDate)];
            }
            // For weekly recurrence, generate the dates manually if RRule failed
            else if (recurrenceObj.frequency === Calendar_type_1.CalendarRecurringTypeEnum.WEEKLY) {
                // Get the target day of week from startDate
                const targetDay = startDate.getDay();
                // Create a new date at the effective start
                let currentDate = new Date(effectiveDtstart);
                // Adjust to the correct day of week if needed
                const dayDiff = (targetDay - currentDate.getDay() + 7) % 7;
                if (dayDiff > 0) {
                    currentDate.setDate(currentDate.getDate() + dayDiff);
                }
                // Generate dates until we reach the until date
                const untilDate = until !== null && until !== void 0 ? until : endDate;
                const manualDates = [];
                while (currentDate <= untilDate) {
                    manualDates.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + (7 * recurrenceObj.interval));
                }
                dates = manualDates;
            }
        }
        // Handle timezone issues for recurrences that need consistent day-of-week
        // Sometimes rrule can generate dates that shift by a day due to timezone conversions
        if (recurrenceObj && (recurrenceObj.frequency === Calendar_type_1.CalendarRecurringTypeEnum.MONTHLY ||
            recurrenceObj.frequency === Calendar_type_1.CalendarRecurringTypeEnum.WEEKLY)) {
            // Always use startDate's day of week as the reference for consistency
            const expectedDay = startDate.getDay();
            // Instead of filtering, adjust each date to ensure it falls on the correct weekday
            dates = dates.map(date => {
                // If the date is not on the expected day, adjust it
                if (date.getDay() !== expectedDay) {
                    // Create a new date using components to avoid timezone issues
                    const correctedDate = new Date(date.getFullYear(), date.getMonth(), date.getDate() + (expectedDay - date.getDay() + 7) % 7, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                    return correctedDate;
                }
                return date;
            });
        }
        return {
            rule,
            ruleSet,
            dates,
        };
    }
    /**
     * Combines date and time fields from a CalendarItem into DateTime objects
     *
     * @param calendarItem The calendar item containing date and time fields
     * @returns Object containing eventStartDateTime and eventEndDateTime as Date objects
     */
    static getEventDateTimes(calendarItem) {
        // Initialize return values
        let eventStartDateTime = null;
        let eventEndDateTime = null;
        // Check if we have the required start date
        if (calendarItem.getEventStartDate()) {
            try {
                // Try to combine date and time
                const startDate = calendarItem.getEventStartDate();
                const startTime = calendarItem.getEventStartTime() || '00:00'; // Default to midnight if no time
                // Combine with ISO format: YYYY-MM-DDTHH:MM
                eventStartDateTime = new Date(`${startDate}T${startTime}`);
                // Verify the date is valid
                if (isNaN(eventStartDateTime.getTime())) {
                    eventStartDateTime = null;
                }
            }
            catch (e) {
                console.error('Error creating eventStartDateTime:', e);
                eventStartDateTime = null;
            }
        }
        // Check if we have the required end date
        if (calendarItem.getEventEndDate()) {
            try {
                // Try to combine date and time
                const endDate = calendarItem.getEventEndDate();
                const endTime = calendarItem.getEventEndTime() || '23:59'; // Default to end of day if no time
                // Combine with ISO format: YYYY-MM-DDTHH:MM
                eventEndDateTime = new Date(`${endDate}T${endTime}`);
                // Verify the date is valid
                if (isNaN(eventEndDateTime.getTime())) {
                    eventEndDateTime = null;
                }
            }
            catch (e) {
                console.error('Error creating eventEndDateTime:', e);
                eventEndDateTime = null;
            }
        }
        return {
            eventStartDateTime,
            eventEndDateTime
        };
    }
    /**
     * Creates a stringified recurrence object from a CalendarItem
     *
     * @param calendarItem The calendar item containing recurrence information
     * @returns Stringified JSON object containing recurrence configuration
     */
    static getRecurrenceValueFromCalendarItem(calendarItem) {
        if (!calendarItem) {
            return JSON.stringify({
                frequency: Calendar_type_1.CalendarRecurringTypeEnum.NONE,
                interval: 1,
                nth: 0,
            });
        }
        // Check if it's a recurring event
        const frequency = calendarItem.getFrequency();
        // If no frequency is set, return a non-recurring configuration
        if (!frequency) {
            return JSON.stringify({
                frequency: Calendar_type_1.CalendarRecurringTypeEnum.NONE,
                interval: 1,
                nth: 0,
            });
        }
        // Map the string frequency to the enum value
        let freq = Calendar_type_1.CalendarRecurringTypeEnum.NONE;
        switch (frequency.toUpperCase()) {
            case 'WEEKLY':
                freq = Calendar_type_1.CalendarRecurringTypeEnum.WEEKLY;
                break;
            case 'MONTHLY':
                freq = Calendar_type_1.CalendarRecurringTypeEnum.MONTHLY;
                break;
            case 'ANNUALLY':
            case 'YEARLY':
                freq = Calendar_type_1.CalendarRecurringTypeEnum.ANNUALLY;
                break;
            default:
                freq = Calendar_type_1.CalendarRecurringTypeEnum.NONE;
        }
        // Get the interval and nth values, with defaults
        const interval = calendarItem.getInterval() || 1;
        let nth = calendarItem.getNth() || 0;
        // For weekly and annually recurrences, we don't use nth
        if (freq === Calendar_type_1.CalendarRecurringTypeEnum.WEEKLY || freq === Calendar_type_1.CalendarRecurringTypeEnum.ANNUALLY) {
            nth = 0;
        }
        // Create and return the stringified recurrence object
        return JSON.stringify({
            frequency: freq,
            interval,
            nth
        });
    }
    /**
     * Generates RRule and associated dates for a CalendarItem
     *
     * This function is a wrapper around generateRRule that accepts a CalendarItem instance
     * instead of individual parameters. It extracts the necessary data from the CalendarItem
     * and calls the original generateRRule method.
     *
     * @param calendarItem The calendar item to generate RRule for
     * @param options Optional overrides for dtstart, until, etc.
     * @returns Object containing RRule instance, RRuleSet (if exclusions exist), and generated dates
     */
    static generateRRuleFromCalendarItem(calendarItem, options) {
        // First get the date/time objects from the calendar item
        const { eventStartDateTime, eventEndDateTime } = this.getEventDateTimes(calendarItem);
        if (!eventStartDateTime || !eventEndDateTime) {
            // Return empty result if date/times cannot be created
            return {
                rule: null,
                ruleSet: null,
                dates: [],
            };
        }
        // Get the recurrence configuration
        let recurrenceString = this.getRecurrenceValueFromCalendarItem(calendarItem);
        let recurrence;
        try {
            recurrence = JSON.parse(recurrenceString);
        }
        catch (e) {
            console.error('Error parsing recurrence string:', e);
            // Return empty result if recurrence cannot be parsed
            return {
                rule: null,
                ruleSet: null,
                dates: [],
            };
        }
        // Get exclude dates if any
        const excludeDates = calendarItem.getExcludeDates();
        let recurringStartDate = calendarItem.getRecurringStartDate()
            ? DateUtils_1.DateUtils.ensureValidDate(calendarItem.getRecurringStartDate())
            : null;
        let recurringEndDate = calendarItem.getRecurringEndDate()
            ? DateUtils_1.DateUtils.ensureValidDate(calendarItem.getRecurringEndDate())
            : null;
        // if recurringStartDate is greater than dtstart, use it
        const recurringStart = (options === null || options === void 0 ? void 0 : options.dtstart) && recurringStartDate && options.dtstart < recurringStartDate
            ? recurringStartDate
            : ((options === null || options === void 0 ? void 0 : options.dtstart) || eventStartDateTime);
        // if recurringEndDate is less then until, use it
        const recurringEnd = (options === null || options === void 0 ? void 0 : options.until) && recurringEndDate && options.until > recurringEndDate
            ? recurringEndDate
            : ((options === null || options === void 0 ? void 0 : options.until) || eventEndDateTime);
        // Create options for generateRRule
        const rRuleOptions = {
            recurrence: recurrence,
            startDate: eventStartDateTime,
            endDate: eventEndDateTime,
            excludeDates: excludeDates,
            dtstart: recurringStart,
            until: recurringEnd,
        };
        // Call the original generateRRule function
        return this.generateRRule(rRuleOptions);
    }
}
exports.CalendarUtils = CalendarUtils;
//# sourceMappingURL=CalendarUtils.js.map