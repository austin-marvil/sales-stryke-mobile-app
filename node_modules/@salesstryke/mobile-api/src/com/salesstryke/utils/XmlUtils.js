"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlUtils = void 0;
class XmlUtils {
    /**
     * Converts an XML Node to a JSON object (recursive, generic).
     */
    static xmlToJsonFrontEnd(xml) {
        // xml as Node, typically an Element or Document. type assertion to any to avoid build errors
        try {
            const obj = {};
            if (xml.nodeType === 1) {
                // element
                // xml as Element. type assertion to any to avoid build errors
                const el = xml;
                if (el.attributes && el.attributes.length > 0) {
                    obj['@attributes'] = {};
                    for (let j = 0; j < el.attributes.length; j++) {
                        const attribute = el.attributes.item(j);
                        if (attribute)
                            obj['@attributes'][attribute.nodeName] = attribute.nodeValue;
                    }
                }
            }
            if (xml.hasChildNodes()) {
                for (let i = 0; i < xml.childNodes.length; i++) {
                    const item = xml.childNodes.item(i);
                    if (item.nodeType === 3 || item.nodeType === 4) {
                        // text (3) or CDATA section (4)
                        const textContent = item.nodeValue;
                        if (textContent && (item.nodeType === 4 || textContent.trim())) {
                            // Preserve CDATA content exactly, only trim regular text nodes
                            obj['#text'] = item.nodeType === 4 ? textContent : textContent.trim();
                        }
                    }
                    else {
                        const nodeName = item.nodeName;
                        if (!obj[nodeName]) {
                            obj[nodeName] = XmlUtils.xmlToJsonFrontEnd(item);
                        }
                        else {
                            if (!Array.isArray(obj[nodeName])) {
                                obj[nodeName] = [obj[nodeName]];
                            }
                            obj[nodeName].push(XmlUtils.xmlToJsonFrontEnd(item));
                        }
                    }
                }
            }
            return obj;
        }
        catch (error) {
            throw new Error(`Failed to convert XML to JSON: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
}
exports.XmlUtils = XmlUtils;
//# sourceMappingURL=XmlUtils.js.map