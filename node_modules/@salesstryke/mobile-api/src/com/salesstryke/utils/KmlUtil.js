"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KmlUtil = void 0;
const tslib_1 = require("tslib");
const persistable_1 = require("../entity/classes/persistable");
const enums_1 = require("../entity/enums");
const RandomData_1 = require("./RandomData");
const StringUtils_1 = require("./StringUtils");
const fillColor = '#ff0000';
const strokeColor = '#0000ff';
const fillOpacity = '0.35';
const strokeOpacity = '0.8';
const strokeWeight = '2';
class KmlUtil {
    /**
     * Parses a KML coordinates string into an array of {lat, lng, alt?} objects.
     */
    static parseCoordinatesString(coordString) {
        return coordString
            .split(/\s+/)
            .map(s => s.trim())
            .filter(Boolean)
            .map(pair => {
            const [lng, lat, alt] = pair.split(',').map(Number);
            const obj = { lat, lng };
            if (!isNaN(alt))
                obj.alt = alt;
            return obj;
        });
    }
    /**
     * Recursively flattens all #text fields in the KML JSON to their proper values.
     * Also splits strings with \n into arrays, and parses 'coordinates' fields.
     */
    static flattenKmlJsonTextFields(obj, parentKey) {
        if (typeof obj !== 'object' || obj === null) {
            if (typeof obj === 'string' && obj.includes('\n')) {
                const arr = obj.split('\n').map(s => s.trim()).filter(Boolean);
                if (parentKey === 'coordinates') {
                    return arr.flatMap(this.parseCoordinatesString);
                }
                return arr.length === 1 ? arr[0] : arr;
            }
            if (typeof obj === 'string' && parentKey === 'coordinates') {
                return this.parseCoordinatesString(obj);
            }
            return obj;
        }
        if (Array.isArray(obj)) {
            return obj.map(item => this.flattenKmlJsonTextFields(item, parentKey));
        }
        const keys = Object.keys(obj);
        if (keys.length === 1 && obj['#text'] !== undefined) {
            return this.flattenKmlJsonTextFields(obj['#text'], parentKey);
        }
        for (const key of keys) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                obj[key] = this.flattenKmlJsonTextFields(obj[key], key);
            }
        }
        return obj;
    }
    /**
     * Parses a single Placemark object into one or more KmlGeometry entities.
     */
    static parsePlacemarkToKmlGeometry(placemark) {
        const geometries = [];
        // Helper to create and fill a KmlGeometry for a given geometry type and data
        const createGeometry = (geometryType, geometryData) => {
            const kmlGeometry = new persistable_1.KmlGeometry();
            if (placemark.name)
                kmlGeometry.setName(placemark.name);
            if (placemark.description) {
                let desc = placemark.description;
                try {
                    // Handle the case where description is an object with #text property (from CDATA)
                    if (typeof desc === 'object' && desc !== null && '#text' in desc) {
                        desc = desc['#text'];
                    }
                    // Handle array case
                    if (Array.isArray(desc)) {
                        desc = desc.join(' ');
                    }
                    // Handle any other object type
                    if (typeof desc === 'object' && desc !== null) {
                        desc = JSON.stringify(desc);
                    }
                    // Ensure we have a string or null to match the method's expected type
                    let cleanDesc;
                    if (desc === null || desc === undefined) {
                        cleanDesc = null;
                    }
                    else {
                        cleanDesc = StringUtils_1.StringUtils.cleanForJson(String(desc));
                    }
                    kmlGeometry.setDescription(cleanDesc);
                }
                catch (error) {
                    console.error('Error cleaning description for KML geometry:', error);
                    console.error('Original description:', placemark.description);
                }
            }
            kmlGeometry.setGeometryType(geometryType);
            kmlGeometry.setGeometryData(geometryData);
            kmlGeometry.setId(`temp_${RandomData_1.RandomData.getRandomHash(10)}`);
            kmlGeometry.setFillColor(fillColor);
            kmlGeometry.setStrokeColor(strokeColor);
            kmlGeometry.setFillOpacity(fillOpacity);
            kmlGeometry.setStrokeOpacity(strokeOpacity);
            kmlGeometry.setStrokeWeight(strokeWeight);
            geometries.push(kmlGeometry);
        };
        // Handle Point (including circle with ExtendedData)
        if (placemark.Point) {
            const point = placemark.Point;
            if (point && 'coordinates' in point) {
                // Check for ExtendedData shapeType
                let shapeType = '';
                let radius;
                let center;
                if (placemark.ExtendedData && typeof placemark.ExtendedData === 'object') {
                    const ext = placemark.ExtendedData;
                    const dataArr = Array.isArray(ext.Data) ? ext.Data : [ext.Data];
                    for (const d of dataArr) {
                        if (d && typeof d === 'object' && d['@_name'] === 'shapeType' && d.value)
                            shapeType = d.value;
                        if (d && typeof d === 'object' && d['@_name'] === 'radius' && d.value)
                            radius = Number(d.value);
                        if (d && typeof d === 'object' && d['@_name'] === 'center' && d.value) {
                            const [lng, lat] = d.value.split(',').map(Number);
                            center = { lat, lng };
                        }
                    }
                }
                if (shapeType === 'circle' && center && typeof radius === 'number') {
                    createGeometry('circle', { center, radius });
                }
                else {
                    // Default marker
                    const coords = Array.isArray(point.coordinates) ? point.coordinates[0] : point.coordinates;
                    if (coords && typeof coords === 'object' && 'lat' in coords && 'lng' in coords) {
                        createGeometry('marker', { coordinates: [coords] });
                    }
                    else if (typeof coords === 'string') {
                        const [lng, lat] = coords.split(',').map(Number);
                        createGeometry('marker', { coordinates: [{ lat, lng }] });
                    }
                }
            }
        }
        // Handle Polygon (rectangle or polygon)
        if (placemark.Polygon) {
            const polygon = placemark.Polygon;
            const outerBoundaryIs = polygon.outerBoundaryIs;
            const linearRing = outerBoundaryIs === null || outerBoundaryIs === void 0 ? void 0 : outerBoundaryIs.LinearRing;
            let coords;
            if (linearRing && 'coordinates' in linearRing) {
                coords = Array.isArray(linearRing.coordinates)
                    ? linearRing.coordinates
                    : undefined;
                if (!coords && typeof linearRing.coordinates === 'string') {
                    coords = KmlUtil.parseCoordinatesString(linearRing.coordinates).map(({ lat, lng }) => ({ lat, lng }));
                }
            }
            else if ('coordinates' in polygon) {
                coords = Array.isArray(polygon.coordinates)
                    ? polygon.coordinates
                    : undefined;
                if (!coords && typeof polygon.coordinates === 'string') {
                    coords = KmlUtil.parseCoordinatesString(polygon.coordinates).map(({ lat, lng }) => ({ lat, lng }));
                }
            }
            // Treat all polygons (including rectangles) as type 'polygon'
            if (coords) {
                createGeometry('polygon', { coordinates: coords });
            }
        }
        // Extend for other geometry types as later if needed
        return geometries;
    }
    /**
     * Helper to find all Placemark objects in the parsed KML JSON.
     * Handles multiple Folders and Folders containing Documents.
     */
    static findPlacemarks(kmlJson) {
        if (typeof kmlJson !== 'object' || kmlJson === null)
            return [];
        // KML root is usually { kml: { Document: { Placemark: [...] } } } or similar
        let doc = kmlJson;
        if ('kml' in kmlJson) {
            const kml = kmlJson['kml'];
            if (kml && typeof kml === 'object' && 'Document' in kml) {
                doc = kml['Document'];
            }
            else {
                doc = kml;
            }
        }
        else if ('Document' in kmlJson) {
            doc = kmlJson['Document'];
        }
        // Helper to recursively collect placemarks from any object
        const collectPlacemarks = (node) => {
            if (!node || typeof node !== 'object')
                return [];
            const placemarks = [];
            if ('Placemark' in node) {
                let p = node['Placemark'];
                if (!Array.isArray(p))
                    p = [p];
                placemarks.push(...p.filter(Boolean));
            }
            if ('Folder' in node) {
                const folders = Array.isArray(node['Folder']) ? node['Folder'] : [node['Folder']];
                for (const folder of folders) {
                    placemarks.push(...collectPlacemarks(folder));
                }
            }
            if ('Document' in node) {
                const docs = Array.isArray(node['Document']) ? node['Document'] : [node['Document']];
                for (const d of docs) {
                    placemarks.push(...collectPlacemarks(d));
                }
            }
            return placemarks;
        };
        return collectPlacemarks(doc);
    }
    /**
     * Converts a KML XML object to an array of KmlGeometry entities.
     * Each kmlGeometry contains at least: name, type, coordinates, and properties.
     */
    static kmlXmlObjectToGeometryArray(xmlRecord, types) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const kmlJson = yield this.flattenKmlJsonTextFields(xmlRecord);
            const placemarks = this.findPlacemarks(kmlJson);
            let geometries = placemarks.flatMap((placemark) => {
                // Handle MultiGeometry
                if (placemark.MultiGeometry) {
                    const multiGeometry = placemark.MultiGeometry;
                    const multiGeometries = [];
                    for (const key of Object.keys(multiGeometry)) {
                        const geometryObj = multiGeometry[key];
                        if (Array.isArray(geometryObj)) {
                            geometryObj.forEach((g) => {
                                const fakePlacemark = Object.assign(Object.assign({}, placemark), { [key]: g, MultiGeometry: undefined });
                                multiGeometries.push(...this.parsePlacemarkToKmlGeometry(fakePlacemark));
                            });
                        }
                        else {
                            const fakePlacemark = Object.assign(Object.assign({}, placemark), { [key]: geometryObj, MultiGeometry: undefined });
                            multiGeometries.push(...this.parsePlacemarkToKmlGeometry(fakePlacemark));
                        }
                    }
                    return multiGeometries;
                }
                // Single geometry
                return this.parsePlacemarkToKmlGeometry(placemark);
            }).filter(Boolean);
            if (types && types.length > 0) {
                geometries = geometries.filter(g => { var _a; return types.includes((_a = g.getGeometryType()) !== null && _a !== void 0 ? _a : ''); });
            }
            return geometries;
        });
    }
    /**
     * Converts an array of KmlGeometry objects to a JSON.
     * Each geometry is represented as an object with its properties.
     */
    static kmlGeometryToJson(kmlGeometrys) {
        const data = [];
        for (const kmlGeometry of kmlGeometrys) {
            const geoData = {};
            const id = kmlGeometry.getId();
            if (!id) {
                // Skip geometries without an ID
                continue;
            }
            geoData.id = id;
            geoData.name = kmlGeometry.getName() || 'Unnamed Geometry';
            geoData.description = kmlGeometry.getDescription() || 'No Description';
            geoData.geometryType = kmlGeometry.getGeometryType() || 'unknown';
            geoData.geometryData = kmlGeometry.getGeometryData() || {};
            geoData.isActive = kmlGeometry.getIsActive() || false;
            // geoData['activeDate'] = kmlGeometry.getActiveDate() || null;
            geoData.kmlType = kmlGeometry.getKmlType() || '';
            data.push(geoData);
        }
        return data;
    }
    /**
     * Converts an array of KmlLayer objects to a JSON.
     * Each layer is represented as an object with its properties.
     */
    static kmlLayerToJson(kmlLayer) {
        const data = [];
        for (const layer of kmlLayer) {
            const layerData = {};
            if (!layer.getId()) {
                // Skip layers without an ID
                continue;
            }
            layerData.id = layer.getId() || '';
            layerData.name = layer.getName() || 'Unnamed Layer';
            layerData.description = layer.getDescription() || 'No Description';
            layerData.kmlGeometries = this.kmlGeometryToJson(layer.getKmlGeometries());
            layerData.kmlType = layer.getKmlType() || '';
            layerData.isActive = layer.getIsActive() || false;
            data.push(layerData);
        }
        return data;
    }
    /**
     * Converts a Kml object to a JSON representation.
     * The Kml object is represented as an object with its properties.
     */
    static kmlToJson(kml) {
        var _a, _b, _c;
        if (!kml.getId()) {
            // Skip KML without an ID
            return null;
        }
        const kmlData = {};
        kmlData.id = kml.getId() || '';
        kmlData.name = kml.getName() || 'Unnamed KML';
        kmlData.description = kml.getDescription() || 'No Description';
        kmlData.kmlLayers = this.kmlLayerToJson(kml.getKmlLayers());
        kmlData.organizationId = ((_a = kml.getOrganization()) === null || _a === void 0 ? void 0 : _a.getId()) || '';
        kmlData.organizationName = ((_b = kml.getOrganization()) === null || _b === void 0 ? void 0 : _b.getName()) || '';
        kmlData.kmlType = ((_c = kml.getKmlType()) === null || _c === void 0 ? void 0 : _c.getName()) || '';
        kmlData.isActive = kml.getIsActive() || false;
        // kmlData['activeDate'] = kml.getActiveDate() || null;
        return kmlData;
    }
    /**
     * Reads and parses the output from kmlToJson (array of KML geometries as JSON string or object).
     * Returns an array of KmlGeometry entity class objects.
     */
    static parseKmlGeometryJsonToEntity(json) {
        let arr;
        if (typeof json === 'string') {
            try {
                arr = JSON.parse(json);
            }
            catch (e) {
                throw new Error('Invalid JSON string provided to parseKmlGeometryJsonToEntity');
            }
        }
        else if (Array.isArray(json)) {
            arr = json;
        }
        else {
            throw new Error('Input to parseKmlGeometryJsonToEntity must be a JSON string or an array of objects');
        }
        // Convert each plain object to a KmlGeometry entity class instance
        return arr.map((obj) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const kmlGeometry = new persistable_1.KmlGeometry();
            kmlGeometry.setId((_a = obj.id) !== null && _a !== void 0 ? _a : null);
            kmlGeometry.setName((_b = obj.name) !== null && _b !== void 0 ? _b : null);
            kmlGeometry.setDescription((_c = obj.description) !== null && _c !== void 0 ? _c : null);
            kmlGeometry.setGeometryType((_d = obj.geometryType) !== null && _d !== void 0 ? _d : null);
            kmlGeometry.setIsActive((_e = obj.isActive) !== null && _e !== void 0 ? _e : false);
            kmlGeometry.setKmlType((_h = (_g = enums_1.KmlTypeEnum.GENERAL.getByName({ name: (_f = obj.kmlType) !== null && _f !== void 0 ? _f : '' })) === null || _g === void 0 ? void 0 : _g.getKmlType()) !== null && _h !== void 0 ? _h : null);
            kmlGeometry.setGeometryData((_j = obj.geometryData) !== null && _j !== void 0 ? _j : {});
            return kmlGeometry;
        });
    }
    /**
     * Reads and parses the output from kmlToJson (array of KML layers as JSON string or object).
     * Returns an array of KmlLayer entity class objects.
     */
    static parseKmlLayerJsonToEntity(json) {
        let arr;
        if (typeof json === 'string') {
            try {
                arr = JSON.parse(json);
            }
            catch (e) {
                throw new Error('Invalid JSON string provided to parseKmlLayerJsonToEntity');
            }
        }
        else if (Array.isArray(json)) {
            arr = json;
        }
        else {
            throw new Error('Input to parseKmlLayerJsonToEntity must be a JSON string or an array of objects');
        }
        // Convert each plain object to a KmlLayer entity class instance
        return arr.map((obj) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const kmlLayer = new persistable_1.KmlLayer();
            kmlLayer.setId((_a = obj.id) !== null && _a !== void 0 ? _a : null);
            kmlLayer.setName((_b = obj.name) !== null && _b !== void 0 ? _b : null);
            kmlLayer.setDescription((_c = obj.description) !== null && _c !== void 0 ? _c : null);
            kmlLayer.setKmlType((_f = (_e = enums_1.KmlTypeEnum.GENERAL.getByName({ name: (_d = obj.kmlType) !== null && _d !== void 0 ? _d : '' })) === null || _e === void 0 ? void 0 : _e.getKmlType()) !== null && _f !== void 0 ? _f : null);
            kmlLayer.setIsActive((_g = obj.isActive) !== null && _g !== void 0 ? _g : false);
            kmlLayer.setKmlGeometries(this.parseKmlGeometryJsonToEntity((_h = obj.kmlGeometries) !== null && _h !== void 0 ? _h : []));
            return kmlLayer;
        });
    }
    /**
     * Reads and parses the output from kmlToJson (array of KML objects as JSON string or object).
     * Returns an array of Kml entity class objects.
     */
    static parseKmlJsonToEntity(json) {
        let arr;
        if (typeof json === 'string') {
            try {
                arr = JSON.parse(json);
            }
            catch (e) {
                throw new Error('Invalid JSON string provided to parseKmlJsonToEntity');
            }
        }
        else if (Array.isArray(json)) {
            arr = json;
        }
        else {
            throw new Error('Input to parseKmlJsonToEntity must be a JSON string or an array of objects');
        }
        // Convert each plain object to a Kml entity class instance
        return arr.map((obj) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const kml = new persistable_1.Kml();
            kml.setId((_a = obj.id) !== null && _a !== void 0 ? _a : null);
            kml.setName((_b = obj.name) !== null && _b !== void 0 ? _b : null);
            kml.setDescription((_c = obj.description) !== null && _c !== void 0 ? _c : null);
            kml.setOrganization(new persistable_1.Organization().setId((_d = obj.organizationId) !== null && _d !== void 0 ? _d : null).setName((_e = obj.organizationName) !== null && _e !== void 0 ? _e : null));
            kml.setKmlType((_h = (_g = enums_1.KmlTypeEnum.GENERAL.getByName({ name: (_f = obj.kmlType) !== null && _f !== void 0 ? _f : '' })) === null || _g === void 0 ? void 0 : _g.getKmlType()) !== null && _h !== void 0 ? _h : null);
            kml.setIsActive((_j = obj.isActive) !== null && _j !== void 0 ? _j : false);
            kml.setKmlLayers(this.parseKmlLayerJsonToEntity((_k = obj.kmlLayers) !== null && _k !== void 0 ? _k : []));
            return kml;
        });
    }
    static createS3FileName(kml) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const id = (_a = kml.getId()) !== null && _a !== void 0 ? _a : '';
        if (!id) {
            return null;
        }
        // setFileName Organization_Workspace_KmlId.json
        const organizationName = (_c = (_b = kml.getOrganization()) === null || _b === void 0 ? void 0 : _b.getName()) !== null && _c !== void 0 ? _c : null;
        // TODO: update later when Kml has a workspace
        const workspaceName = (_h = (_g = (_f = (_e = (_d = kml).getWorkspace) === null || _e === void 0 ? void 0 : _e.call(_d)) === null || _f === void 0 ? void 0 : _f.getName) === null || _g === void 0 ? void 0 : _g.call(_f)) !== null && _h !== void 0 ? _h : null; // fallback for missing workspace
        const newFileName = `${organizationName}_${workspaceName}_${id}.json`;
        return newFileName;
    }
    static parseS3FileName(fileName) {
        // Expect: Organization_Workspace_KmlId.json
        const match = fileName.match(/^(.+?)_(.+?)_(.+?)\.json$/);
        if (match) {
            const [, organizationName, workspaceName, kmlId] = match;
            return { organizationName, workspaceName, kmlId };
        }
        return null;
    }
}
exports.KmlUtil = KmlUtil;
//# sourceMappingURL=KmlUtil.js.map