"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorBase = void 0;
/**
        try {

        }
        catch(error_any: any) {
            let error: Error = (error_any as Error);
            let errorBase: ErrorBase = new ErrorBase(error.message, "", error);
            if(LOGGER.isErrorEnabled()) { LOGGER.logError(`. ${EntityComponentRenderer.#renderMethodName_s} ${errorBase.getMessage()}`); }
        }
        finally {

        }
 */
class ErrorBase extends Error {
    constructor(message_s, namespace_s, methodName_s, errorUUID_s, parentError_any) {
        // 'Error' breaks prototype chain here
        //super(message_s);
        super((typeof message_s === 'string' ? message_s : message_s.message));
        this.message_s = "";
        this.methodName_s = null;
        this.namespace_s = null;
        this.parentError = null;
        this.uuid_s = null;
        this.name = this.constructor.name;
        Object.setPrototypeOf(this, ErrorBase.prototype);
        if (typeof message_s === 'string') {
            this.message_s = message_s;
            if (namespace_s) {
                this.namespace_s = namespace_s;
            }
            if (methodName_s) {
                this.methodName_s = methodName_s;
            }
            if (errorUUID_s) {
                this.uuid_s = errorUUID_s;
            }
            this.parentError = parentError_any;
        }
        else {
            const p = message_s;
            this.message_s = p.message;
            if (p.errorUUID) {
                this.uuid_s = p.errorUUID;
            }
            if (p.methodName) {
                this.methodName_s = p.methodName;
            }
            if (p.namespace) {
                this.namespace_s = p.namespace;
            }
            if (p.parentError_any) {
                this.parentError = p.parentError_any;
            }
        }
        if (this.parentError instanceof ErrorBase) {
            this.parentError = parentError_any;
        }
        else {
            if (parentError_any) {
                let tempError = parentError_any;
                this.parentError = new ErrorBase(tempError.message);
            }
        }
    }
    static getAsErrorBase(error_any) {
        let errorBase;
        if (error_any instanceof ErrorBase) {
            errorBase = error_any;
        }
        else {
            let error = error_any;
            errorBase = new ErrorBase(error.message);
        }
        return (errorBase);
    }
    /**
     * Returns the errorMessage, namespace, methodname, and error uuid.
     * @returns
     */
    getFullMessage() {
        let message_s = "";
        if (this.namespace_s !== null && this.namespace_s !== undefined) {
            message_s += ` ${this.namespace_s}`;
        }
        if (this.methodName_s !== null && this.methodName_s !== undefined) {
            message_s += `.${this.methodName_s}`;
        }
        if (this.message_s !== null && this.message_s !== undefined) {
            message_s += ` ${this.message_s} `;
        }
        if (this.uuid_s !== null && this.uuid_s !== undefined) {
            message_s += ` Error uuid:${this.uuid_s}`;
        }
        message_s += '.';
        if (this.parentError !== null && this.parentError !== undefined) {
            let parentMessage_s = this.parentError.getFullMessage();
            if (parentMessage_s !== "") {
                message_s += ` Stack: ${parentMessage_s}`;
            }
        }
        return (message_s);
    }
    getMethodName() {
        return (this.methodName_s);
    }
    /**
     * Returns the error message and the error uuid.
     * @returns
     */
    getMessage() {
        // let message_s: string = "";
        // message_s += ` ${this.message_s} `
        // if(this.uuid_s !== null) 
        // {
        //     message_s += ` error uuid:${this.uuid_s}`;
        // }
        return (this.message_s);
    }
    getNamespace() {
        return (this.namespace_s);
    }
    getParentError() {
        return (this.parentError);
    }
    getUUID() {
        return (this.uuid_s);
    }
    setParentError(parentError) {
        this.parentError = parentError;
    }
    toString() {
        let error = '';
        error += this.message;
        if (this.uuid_s) {
            error += ` ${this.uuid_s}`;
        }
        return (error);
    }
}
exports.ErrorBase = ErrorBase;
//# sourceMappingURL=ErrorBase.js.map